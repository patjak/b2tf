#!/usr/bin/php
<?php

define("DEBUG", true);

// How long back in commit history we check for cherry picks
define("CHERRY_PICK_HISTORY", 4000);

$progname = basename($argv[0]);

function msg($msg)
{
	echo $msg."\n";
}

function fatal($msg)
{
	echo "\e[31m".$msg."\e[0m\n";
	exit(1);
}

function error($msg)
{
	echo "\e[31m".$msg."\e[0m\n";
}

function info($msg)
{
	echo "\e[34m".$msg."\e[0m\n";
}

function green($msg)
{
	echo "\e[32m".$msg."\e[0m\n";
}

function debug($msg)
{
	if (DEBUG) 
		echo "\e[33m".$msg."\e[0m\n";
}

function delimiter()
{
	echo "\e[33m----------\e[0m\n";
}

class Patch {
	var $filename; // Includes the full path
	var $commit_id; // Hash
	var $author;
	var $date;
	var $subject;
	var $signatures = array();
	var $reviews = array();
	var $cherry_pick;

	// Get the contents of a tag and store in $var
	// $tag is not case sensitive
	private function get_tag($line, $tag, &$var) {
		$line = trim($line);
		if (substr($line, 0, strlen($tag)) === $tag) {
			$tag = substr($line, strlen($tag));

			// Append to array if needed
			if (is_array($var))
				$var[] = $tag;
			else
				$var = $tag;
				
		}
	}

	// Read out all tags from patch file or 'git log' and store in object
	public function parse($filename) {
		$file = file_get_contents($filename);
		$file = explode("---".PHP_EOL, $file);
		$head = $file[0];

		$head = explode(PHP_EOL, $head);

		// Patch format and git format are different
		if (isset($file[1])) {
			// Patch format
			$body = $file[1];
		} else {
			// Git format
			$body = "";

			// Special case for the subject
			$this->subject = trim($head[4]);
		}

		// First line is always commit id
		$commit_id = array_shift($head);
		$commit_id = explode(" ", $commit_id);
		$this->commit_id = $commit_id[1];

		// Parse rest of head
		foreach($head as $line) {
			$this->filename = realpath($filename);
			$this->get_tag($line, "From: ", $this->author);
			$this->get_tag($line, "Date: ", $this->date);
			$this->get_tag($line, "Subject: ", $this->subject);
			$this->get_tag($line, "Signed-off-by: ", $this->signatures);
			$this->get_tag($line, "Reviewed-by: ", $this->reviews);
			$this->get_tag($line, "(cherry picked from commit ", $this->cherry_pick);
		}

		$this->cherry_pick = substr($this->cherry_pick, 0, -1);
	}

	// Read out patch header (body not included) from git commit
	public function parse_from_git($commit_id, $git) {
		$filename = "/tmp/tmp-patch.tmp";

		$git->cmd("git log -n1 ".$commit_id, $output);
		$output = implode(PHP_EOL, $output);
		file_put_contents($filename, $output);
		$this->parse($filename);
		unlink($filename);
	}

	// Find and return the patch with specified commit
	public static function get_by_commit($commit, $patches) {
		foreach($patches as $p) {
			if ($p->commit_id == $commit)
				return $p;
		}

		return FALSE;
	}

	// Return all patches in the work dir as an array
	public static function get_patches($work_dir) {
		$files = get_patch_filenames($work_dir);
		$patches = array();
		foreach ($files as $file) {
			$p = new Patch();
			$p->parse($file);
			$patches[] = $p;
		}

		return $patches;
	}

	// Returns the patch for the next commit to be processed from the log
	public static function get_next_in_log($log, $work_dir)
	{
		$patches = Patch::get_patches($work_dir);
		$next = $log->get_next_commit();
		$p = Patch::get_by_commit($next, $patches);

		return $p;
	}
}

class Log {
	var $filename = FALSE;
	var $head; // Backport setup data
	var $body; // Commits
	var $tail; // Postponed commits

	// Load the log from the work directory
	public function load($filename) {
		$this->filename = $filename;
		$tmp = file_get_contents($filename);
		if ($tmp === FALSE || strlen($tmp) == 0)
			return FALSE;

		$tmp = explode("---".PHP_EOL, $tmp);
		$this->head = $tmp[0];
		$this->body = $tmp[1];
		if (isset($tmp[2]))
			$this->tail = $tmp[2];
		else
			$this->tail = "";
	}

	// Save the log to the work directory
	public function save($filename = FALSE) {
		$contents  = $this->head."---".PHP_EOL.$this->body."---".$this->tail;
		if ($filename === FALSE)
			$filename = $this->filename;
		file_put_contents($filename, $contents);
	}

	public function get_head() { return $this->head; }
	public function append_head($str) { $this->head .= $str; }

	public function get_body() { return $this->body; }
	public function set_body($body) { $this->body = $body; }
	public function append_body($str) { $this->body .= $str; }

	// Get the contents of a tag and store in $var
	private function get_tag($line, $tag, &$var) {
		$tag = strtolower($tag);
		if (strtolower(substr($line, 0, strlen($tag))) === $tag) {
			$tag = substr($line, strlen($tag));

			// Append to array if needed
			if (is_array($var))
				$var[] = $tag;
			else
				$var = $tag;
		}
	}

	// Find requested tag in head and return it
	public function get_head_tag($tag) {
		if ($this->filename === FALSE)
			return FALSE;

		$head = explode(PHP_EOL, $this->get_head());

		foreach($head as $line) {
			$this->get_tag($line, $tag.": ", $res);
		}
		
		return $res;
	}

	// Set backport commit id for specified upstream commit id
	public function update_commit($upstream_id, $backport_id) {
		if ($this->filename === FALSE)
			return FALSE;

		$body = explode(PHP_EOL, $this->get_body());

		// Find row
		for ($i = 0; $i < count($body); $i++) {
			$line = $body[$i];
			if (trim($line) == "")
				continue;

			$line = explode(" ", $line);
			if ($line[0] == "#")
				continue;
	
			if ($line[0] == $upstream_id) {
				$body[$i] = $upstream_id." ".$backport_id;
				break;
			}
		}

		if ($i == count($body))
			fatal("Couldn't find upstream commit: ".$upstream_id);

		$body = implode(PHP_EOL, $body);
		$this->set_body($body);
		$this->save();
	}

	// Return the latest applied commit from log as array [upstream_id, backport_id]
	public function get_last_commit() {
		$body = $this->get_body();
		$body = explode(PHP_EOL, $body);

		$prev_line = "";
		foreach ($body as $line) {
			if ($line == "")
				continue;
			$line = explode(" ", $line);
			if ($line[0] == "#")
				continue;
			if (count($line) == 1)
				return $prev_line;
			if ($line[1] == "")
				return $prev_line;

			$prev_line = $line;
		}

		return $prev_line;
	}

	// Find the next commit id to process from the commit log
	public function get_next_commit() {
		$body = $this->get_body();
		$body = explode(PHP_EOL, $body);

		foreach ($body as $line) {
			if ($line == "")
				continue;
			$line = explode(" ", $line);
			if ($line[0] == "#")
				continue;
			if (count($line) == 1)
				return $line[0];
			if ($line[1] == "")
				return $line[0];
		}
	}

	public function get_num_commits() {
		$body = $this->get_body();
		$body = explode(PHP_EOL, $body);

		$i = 0;
		foreach ($body as $line) {
			$line = explode(" ", $line);
			if ($line[0] == "#")
				continue;
			if ($line[0] == "")
				continue;

			$i++;
		}

		return $i;
	}

	public function get_commit_index($commit_id) {
		$body = $this->get_body();
		$body = explode(PHP_EOL, $body);

		$i = 1;
		foreach ($body as $line) {
			$line = explode(" ", $line);
			if ($line[0] == "#")
				continue;
			if ($line[0] == "")
				continue;

			if ($commit_id == $line[0])
				return $i;

			$i++;
		}

		return FALSE;
	}

	// Sanity check last entry in log
	function sanity_check_last($git) {
		// Sanity check log vs git-repo
		$last = $this->get_last_commit();
		if (strlen($last[1]) == 40) {
			$p1 = new Patch(); // Upstream commit
			$p2 = new Patch(); // Backport commit
			$p1->parse_from_git($last[0], $git);
			$p2->parse_from_git($last[1], $git);
			if ($p1->subject != $p2->subject) {
				fatal("Commit log is corrupted. Must be fixed manually.\n(".
				      $p1->subject." != ".$p2->subject.")");
			}
		}
	}
}

class GitRepo {
	var $dir;

	public function set_dir($dir) { $this->dir = $dir; }
	public function get_dir() { return $this->dir; }

	// Run a shell command in the git repository directory
	public function cmd($cmd, &$output = FALSE, &$status = FALSE) {
		exec("cd ".$this->dir." && ".$cmd, $output, $status);
	}

	// Returns the currently selected branch
	public function get_current_branch() {
		$this->cmd("git branch --show-current", $name);

		return $name[0];
	}

	// Returns the commit id of the latest committed patch
	public function get_current_commit_id() {
		$this->cmd("git rev-list HEAD~1..HEAD", $git_head);

		return $git_head[0];
	}

	private function parse_status_paths($str, $line_skip) {
		$this->cmd("git status", $output);

		while (count($output) > 0 && $output[0] != $str)
			array_shift($output);

		// Parse the modified files from output
		$output = array_splice($output, $line_skip);
		$paths = array();
		foreach ($output as $o) {
			if ($o == "")
				break;
			$o = explode(":", $o);
			$paths[] = trim($o[1]);
		}

		return $paths;
	}

	// Returns an array of unmerged paths
	public function get_unmerged_paths() {
		return $this->parse_status_paths("Unmerged paths:", 3);
	}

	// Returns an array of paths to be commited
	public function get_modified_paths() {
		return $this->parse_status_paths("Changes to be committed:", 2);
	}

	// Returns an array of paths not staged for commit
	public function get_unstaged_paths() {
		return $this->parse_status_paths("Changes not staged for commit:", 2);
	}

	// Switch to a different git branch
	public function change_branch($log) {
		$range_start = $log->get_head_tag("range-start");
		$branch = $log->get_head_tag("branch");

		if ($branch == "")
			fatal("Invalid branch. Did you run setup properly?");

		if ($this->get_current_branch() != $branch) {
			$this->cmd("git checkout ".$branch." 2> /dev/null", $output, $status);
			if ($status != 0)
				$this->cmd("git checkout -b ".$branch." ".$range_start);
		}

		// Sanity check the branch
		if ($this->get_current_branch() != $branch)
			fatal("Couldn't create/find correct branch");
	}

	// Find where in the patch series we currently are
	public function find_commit_index($commit, $patches) {
		$num = count($patches);
		for ($i = 0; $i < $num; $i++) {
			if ($commit == $patches[$i]->commit_id) {
				break;
			}
		}

		// If commit is not found we start from beginning (index 0)
		if ($i == $num)
			$i = 0;

		return $i;
	}

	public function skip_commit($log, $p, $reason) {
		$this->cmd("git am --skip");
		$log->update_commit($p->commit_id, $reason);
	}

	public function check_for_conflicts() {
		// Check that none of the unmerged paths still contain conflicts
		$unmerged = $this->get_unmerged_paths();
		$conflicts = FALSE;

		foreach ($unmerged as $u) {
			$this->cmd("grep -Hn \"<<<<<<\" ".$u, $res);
			if (count($res) > 0)
				$conflicts = TRUE;
			$this->cmd("grep -Hn \"======\" ".$u, $res);
			if (count($res) > 0)
				$conflicts = TRUE;
			$this->cmd("grep -Hn \">>>>>>\" ".$u, $res);
			if (count($res) > 0)
				$conflicts = TRUE;
		}

		return $conflicts;
	}

	public function check_am_session() {
		$this->cmd("git status", $res);
		if ($res[1] == "You are in the middle of an am session.")
			return TRUE;
		else
			return FALSE;
	}

	function check_for_cherry_pick($log, $p)
	{
		// Check if patch is already cherry picked
		$range_start = $log->get_head_tag("range-start");
		$this->cmd("git log ".$range_start."~".CHERRY_PICK_HISTORY.
			   "..".$range_start." -n1 --oneline --grep=\"cherry picked from commit ".
			   $p->commit_id."\"", $res);

		if (count($res) > 0) {
			info("Patch found in preceding cheery pick (".$res[0].")");
			$res = explode(" ", $res[0]);
			return $res[0];
		}

		return FALSE;
	}
}

function array_to_str($array)
{
	$out = "";
	foreach($array as $line)
		$out .= $line."\n";

	return $out;
}

// Returns filenames for all the exported patches
function get_patch_filenames($dir)
{
	$dir = realpath($dir);
	exec("find ".$dir."| sort | grep \"\\.patch\"", $files);

	return $files;
}

function get_opt($name, $opts)
{
	$opt = isset($opts[$name]) ? $opts[$name] : "";
	if ($opt == "")
		fatal("Missing --".$opt." <arg>");

	return $opt;
}

function launch_editor($unmerged, $p, $log, $git)
{
	$work_dir = $log->get_head_tag("work-dir");

	$solutions = "";
	foreach ($unmerged as $i => $u) {
		// Figure out the extension so that the editor can do syntax highlighting
		$info = pathinfo($u);
		$file_ext = isset($info['extension']) ? $info['extension'] : "";
		if ($file_ext != "")
			$file_ext = ".".$file_ext;
		$solution_name = "solution-tmp".$file_ext;

		// Store the target version of the file (eg git show v5.5:<filename>)
		$git->cmd("git show ".$log->get_head_tag("Range-stop").":".$u." | ".
			"dd of=".$work_dir."/".$solution_name." 2> /dev/null", $output, $status);

		// Add the entire path to modified files
		$u = $git->get_dir()."/".$u;

		// Find line number for first conflict
		$res = "";
		$git->cmd("grep -n \"<<<<<<\" ".$u, $res);
		if (count($res) > 0) {
			$res = explode(":", $res[0]);
			$line_no = " +".$res[0];
		} else {
			$line_no = "";
		}

		// Open vim with all the relevant files
		passthru("vim -O ".$line_no." ".$u." ".$work_dir."/".$solution_name." ".$p->filename." 2> /dev/null");

		exec("rm ".$work_dir."/".$solution_name);
	}
}

function cmd_export($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$start = $log->get_head_tag("range-start");
	$stop = $log->get_head_tag("range-stop");
	$git_dir = $log->get_head_tag("git-dir");
	$paths = $log->get_head_tag("paths");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	// Execute git format-patch
	echo "Exporting patches...";

	$git->cmd("git format-patch --topo-order --keep-subject --no-merges -o ".
		 $work_dir." ".$start."..".$stop." ".$paths);

	$log->set_body("#         <Upstream commit id>".
		       "                   <Backported commit id>\n");
	$files = get_patch_filenames($work_dir);
	$patches = array();
	foreach ($files as $file) {
		$p = new Patch();
		$p->parse($file);
		$patches[] = $p;
		$log->append_body($p->commit_id."\n");
	}

	$log->save($work_dir."/commits.log");

	echo count($files)."\n";
	exit();
}

function cmd_apply($argv, $opts)
{
	global $progname;

	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	$git_dir = $log->get_head_tag("git-dir");
	$range_start = $log->get_head_tag("range-start");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$patches = Patch::get_patches($work_dir);

	$num_patches = count($patches);
	if ($num_patches == 0)
		fatal("No patches to apply. Did you forget to run export?");

	$log->sanity_check_last($git);

	$next_commit = $log->get_next_commit();
	$i = $git->find_commit_index($next_commit, $patches);
	for (; $i < $num_patches; $i++) {
		$p = $patches[$i];

		// Check if we're in an am session
		if ($git->check_am_session()) {
			$unmerged = $git->get_unmerged_paths();
			$unstaged = $git->get_unstaged_paths();

			if (count($unmerged) > 0 || count($unstaged) > 0) {
				error("Repository contains unmerged/unstaged paths. Solve conflict before continuing.");
				launch_editor($unmerged, $p, $log, $git);

				// If all conflicts are fixed we automatically add them
				if ($git->check_for_conflicts() == FALSE)
					cmd_add($argv, $opts);
				else
					error("Unmerged paths still contain conflicts");

				exit(1);
			}

			if (count($git->get_modified_paths()) > 0) {
				debug("In AM session with modified paths. git am --contine");
				$git->cmd("git am --continue");

				$last_id = $git->get_current_commit_id();
				$log->update_commit($p->commit_id, $last_id);
				green("Applied\t(".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
			} else {
				debug("In AM session WITHOUT modified paths. git am --skip");
				$git->cmd("git am --skip");
				$log->update_commit($p->commit_id, "empty");
				info("Empty\t(".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
			}

			continue;
		}

		$filename = $p->filename;
		$output_am = "";

		$old_id = $git->get_current_commit_id();
		$git->cmd("git am --3way ".$filename." 2> /dev/stdout", $output_am, $status);
		$new_id = $git->get_current_commit_id();

		// Check if patch did not apply
		if ($status != 0) {
			// Save git am output to file so we can show it in edit (vim, emacs, etc.)
			file_put_contents($work_dir."/output.tmp", array_to_str($output_am));

			$cherry_id = $git->check_for_cherry_pick($log, $p);
			if ($cherry_id !== FALSE) {
				info("Cherry picked (".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
				$log->update_commit($p->commit_id, "cherry-pick ".$cherry_id);
				$git->cmd("git am --abort");
				continue;
			}

			delimiter();
			echo "Unmerged paths:\n";
			$unmerged = $git->get_unmerged_paths();
			error(array_to_str($unmerged));

			delimiter();
			error("Failed patch: ".basename($p->filename));

			delimiter();
			echo "Fix conflict and rerun apply.\n";
			info("(IMPORTANT! Do NOT run: git am --continue)");

			launch_editor($unmerged, $p, $log, $git);

			// If all conflicts are fixed we automatically add them
			if ($git->check_for_conflicts() == FALSE) {
				cmd_add($argv, $opts);
				exit(0);
			} else {
				error("Unmerged paths still contain conflicts");
			}

			exit(1);
		}

		// Patch might not have introduced changes thus did not get applied (not needed)
		if ($old_id == $new_id) {
			$cherry_id = $git->check_for_cherry_pick($log, $p);
			if ($cherry_id !== FALSE) {
				info("Cherry picked (".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
				$log->update_commit($p->commit_id, "cherry-pick ".$cherry_id);
				continue;
			}

			info("Empty\t(".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
			$log->update_commit($p->commit_id, "empty");
			continue;
		}
		$log->update_commit($p->commit_id, $new_id);
		green("Applied (".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
	
/*
		$git->cmd("make -j16 M=drivers/gpu/drm 2> /dev/null", $res, $status);
		if ($status != 0)
			error("Compilation failed!");
*/
	}

	exit();
}

function cmd_setup($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));
	$branch = get_opt("branch", $opts);
	$range_start = get_opt("start", $opts);
	$range_stop = get_opt("stop", $opts);
	$git_dir = realpath(get_opt("git-dir", $opts));
	$paths = get_opt("paths", $opts);

	$log = new Log();
	$log->append_head("Range-start: ".$range_start."\n");
	$log->append_head("Range-stop: ".$range_stop."\n");
	$log->append_head("Branch: ".$branch."\n");
	$log->append_head("Work-dir: ".$work_dir."\n");
	$log->append_head("Git-dir: ".$git_dir."\n");
	$log->append_head("Paths: ".$paths."\n");

	$log->save($work_dir."/commits.log");

	info("Setup saved to ".$work_dir."/commits.log");
	exit(0);
}

function cmd_add($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$fatal = $git->check_for_conflicts();
	if ($fatal)
		fatal("Unmerged paths still contain conflicts!");

	$unmerged = $git->get_unmerged_paths();
	foreach ($unmerged as $u) {
		$git->cmd("git add ".$u);
	}

	$modified = $git->get_modified_paths();
	echo "Added files:\n";
	foreach ($modified as $m) {
		green("\t".$m);
	}

	exit(0);
}

function cmd_reset($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$git->cmd("git am --abort");
	$git->cmd("git checkout master");
	$git->cmd("git branch -D ".$branch);

	$patches = Patch::get_patches($work_dir);
	foreach ($patches as $p)
		$log->update_commit($p->commit_id, "");

	exit(0);
}

function cmd_skip($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$modified = $git->get_modified_paths();
	if (count($modified) > 0)
		fatal("You have modified paths. Cannot skip!");

	$git->cmd("git am --abort");

	$p = Patch::get_next_in_log($log, $work_dir);
	$num_patches = count(Patch::get_patches($work_dir));

	$cherry_id = $git->check_for_cherry_pick($log, $p);
	if ($cherry_id !== FALSE) {
		info("Cherry picked (?/".$num_patches.") ".$p->commit_id." ".$p->subject);
		$log->update_commit($p->commit_id, "cherry-pick ".$cherry_id);
		return;
	}

	info("Manual skip (?/".$num_patches.") ".$p->commit_id." ".$p->subject);
	$log->update_commit($p->commit_id, "manual-skip");

	cmd_apply($argv, $opts);
}

function cmd_sanity_check($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$body = $log->get_body();
	$body = explode(PHP_EOL, $body);

	$i = 0;
	$j = 0;
	$num_faults = 0;
	foreach ($body as $line) {
		$i++;
		$line = explode(" ", $line);
		if ($line == "")
			continue;
		if ($line[0] == "")
			continue;
		if ($line[0][0] == "#")
			continue;
		if (!isset($line[1]) || $line[1] == "")
			continue;
		if (strlen($line[1]) != 40) {
			// If line is a cherry pick, we compare those instead
			if ($line[1] == "cherry-pick") {
				$line[1] = $line[2];
			} else {
				continue;
			}
		}

		$p1 = new Patch(); // Upstream commit
		$p2 = new Patch(); // Backport commit
		$p1->parse_from_git($line[0], $git);
		$p2->parse_from_git($line[1], $git);
		// info("\"".$p1->subject."\" == \"".$p2->subject."\"");

		if ($p1->commit_id == $p2->commit_id)
			fatal("Comparing the same commit. This shouldn't happen!");

		if ($p1->subject != $p2->subject) {
			error("Commit log is inconsistent at commit: ".$i);
			echo "\t".$p1->commit_id." ".$p1->subject."\n".
			     "\t".$p2->commit_id." ".$p2->subject."\n";
			$num_faults++;
		}

		$j++;
	}

	msg("Processed ".$j." commits");

	if ($num_faults == 0)
		green("Found ".$num_faults." inconsitencies");
	else
		error("Found ".$num_faults." inconsitencies");
}

function cmd_diffstat($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$range_stop = $log->get_head_tag("range-stop");
	$paths = $log->get_head_tag("paths");
	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$res = FALSE;
	$git->cmd("git diff --stat ".$branch." ".$range_stop." ".$paths, $res, $status);
	if ($status != 0)
		fatal("Failed to diff");

	echo array_to_str($res);
}

function cmd_status($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$range_stop = $log->get_head_tag("range-stop");
	$paths = $log->get_head_tag("paths");
	$git_dir = $log->get_head_tag("git-dir");
	$branch = $log->get_head_tag("branch");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$last_commit = $log->get_last_commit();
	$last_commit = $last_commit[0];
	$last_index = $log->get_commit_index($last_commit);
	$num_commits = $log->get_num_commits();

	echo "Progress ".(round(($last_index / $num_commits) * 100, 0))."% (".$last_index."/".$num_commits." commits)\n";

	$res = FALSE;
	$git->cmd("git diff --stat ".$branch." ".$range_stop." ".$paths, $res, $status);
	if ($status != 0)
		fatal("Failed to diff");

	$last_line = count($res) - 1;
	msg(trim($res[$last_line])."\n");


	if ($last_index == $num_commits) {
		msg("Backport is done!");
		return;
	}

	$next_commit = $log->get_next_commit();
	$patches = Patch::get_patches($work_dir);
	$p = Patch::get_by_commit($next_commit, $patches);

	if ($git->check_am_session())
		echo "In AM session on commit:\n";
	else
		echo "Not in AM session. Next commit:\n";
	echo $p->commit_id." ".$p->subject."\n";

	$unmerged = $git->get_unmerged_paths();
	$unstaged = $git->get_unstaged_paths();
	$modified = $git->get_modified_paths();

	if (count($modified) > 0) {
		echo "Modified:\n";
		foreach ($modified as $m) {
			green("\t".$m);
		}
	}

	if (count($unstaged) > 0) {
		echo "Unstaged:\n";
		foreach ($unstaged as $u) {
			green("\t".$u);
		}
	}

	if (count($unmerged) > 0) {
		echo "Unmerged:\n";
		foreach ($unmerged as $u) {
			error("\t".$u);
		}
	}

	echo "\n";
}

function cmd_diff($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$range_stop = $log->get_head_tag("range-stop");
	$paths = $log->get_head_tag("paths");
	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$git->cmd("git diff ".$branch." ".$range_stop." ".$paths, $res, $status);
	if ($status != 0)
		fatal("Failed to diff");

	echo array_to_str($res);
	delimiter();

	$res = FALSE;
	$git->cmd("git diff --stat ".$branch." ".$range_stop." ".$paths, $res, $status);
	if ($status != 0)
		fatal("Failed to diff");

	echo array_to_str($res);
}

function cmd_postpone($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	if ($git->check_am_session()) {
		$git->cmd("git am --abort");
	}

	$branch = $log->get_head_tag("branch");
	$git->change_branch();

}

function parse_options($argv)
{
	$opts = array(
		"start:",
		"stop:",
		"branch:",
		"work-dir:",
		"git-dir:",
		"paths:",
		);

	$options = getopt("", $opts, $optind);

	if (isset($argv[$optind]))
		$command = $argv[$optind];
	else
		return;


	switch($command) {
	case "setup":
		cmd_setup($argv, $options);
		exit(0);
	case "export":
		cmd_export($argv, $options);
		exit(0);
	case "apply":
		cmd_apply($argv, $options);
		exit(0);
	case "skip":
		cmd_skip($argv, $options);
		exit(0);
	case "add":
		cmd_add($argv, $options);
		exit(0);
	case "reset":
		cmd_reset($argv, $options);
		exit(0);
	case "sanity-check":
		cmd_sanity_check($argv, $options);
		exit(0);
	case "status":
		cmd_status($argv, $options);
		exit(0);
	case "diffstat":
		cmd_diffstat($argv, $options);
		exit(0);
	case "diff":
		cmd_diff($argv, $options);
		exit(0);
	case "postpone":
		cmd_postpone($argv, $options);
		exit(0);
	}
}

parse_options($argv);

?>

Usage: <?= $progname ?> <options> <command>

ALL commands require --work-dir to be specified!

Commands:
  setup - Setup all backporting parameters
    --start=<range-start>
    --stop=<range-stop>
    --branch=<name-of-branch-to-do-backport-in>
    --work-dir=<working-directory>
    --git-dir=<git-repository-directory>
    --paths=<paths-in-git-repo-to-backport>
    Example:
    <?= $progname ?> \
      --start=v5.4 --stop=v5.5 --branch=my-backport \
      --work-dir=./empty-dir --git-dir=./linux-git \
      --paths="include/drm/ drivers/gpu/drm/" \
      setup

  export - Runs git-format-patch over the specified range

  apply - Start re-applying the series

  diff- Show diff between current tree vs target tree

  status- Show current status of backport and git repo

Examples:
	Create series of patches (git format-patch)
	<?= $argv[0] ?> get-series

