#!/usr/bin/php
<?php

// How long back in commit history we check for cherry picks
define("CHERRY_PICK_HISTORY", 4000);

$progname = basename($argv[0]);

function msg($msg) { echo $msg."\n"; }
function fatal($msg) { echo "\e[31m".$msg."\e[0m\n"; exit(1); }
function error($msg) { echo "\e[31m".$msg."\e[0m\n"; }
function info($msg) { echo "\e[34m".$msg."\e[0m\n"; }
function green($msg) { echo "\e[32m".$msg."\e[0m\n"; }
function debug($msg) { if (DEBUG) { echo "\e[33m".$msg."\e[0m\n"; } }
function delimiter() { echo "\e[33m----------\e[0m\n"; }

class Patch {
	var $filename; // Includes the full path
	var $commit_id; // Hash
	var $author;
	var $date;
	var $subject;
	var $signatures = array();
	var $reviews = array();
	var $cherry_pick;

	// Get the contents of a tag and store in $var
	// $tag is not case sensitive
	private function get_tag($line, $tag, &$var) {
		$line = trim($line);
		if (substr($line, 0, strlen($tag)) === $tag) {
			$tag = substr($line, strlen($tag));

			// Append to array if needed
			if (is_array($var))
				$var[] = $tag;
			else
				$var = $tag;
				
		}
	}

	// Read out all tags from patch file or 'git log' and store in object
	public function parse($filename) {
		$file = file_get_contents($filename);
		$file = explode("---".PHP_EOL, $file);
		$head = $file[0];

		$head = explode(PHP_EOL, $head);

		// Patch format and git format are different
		if (isset($file[1])) {
			// Patch format
			$body = $file[1];
		} else {
			// Git format
			$body = "";
		}

		// First line is always commit id
		$commit_id = array_shift($head);
		$commit_id = explode(" ", $commit_id);
		$this->commit_id = $commit_id[1];

		// Parse rest of head
		foreach($head as $line) {
			$this->filename = realpath($filename);
			$this->get_tag($line, "From: ", $this->author);
			$this->get_tag($line, "Date: ", $this->date);
			$this->get_tag($line, "Subject: ", $this->subject);
			$this->get_tag($line, "Signed-off-by: ", $this->signatures);
			$this->get_tag($line, "Reviewed-by: ", $this->reviews);
			$this->get_tag($line, "(cherry picked from commit ", $this->cherry_pick);
		}

		$this->subject = str_replace("  ", " ", $this->subject);

		$this->cherry_pick = substr($this->cherry_pick, 0, -1);
	}

	// Read out patch header (body not included) from git commit
	public function parse_from_git($commit_id, $git) {
		$filename = "/tmp/tmp-patch.tmp";

		$git->cmd("git log -n1 ".$commit_id, $output);
		$output = implode(PHP_EOL, $output);
		file_put_contents($filename, $output);
		$this->parse($filename);

		// We don't get the subject when parsing a git commit so do it manually here
		$git->cmd("git log --oneline -n1 ".$commit_id, $output);
		$output = explode(" ", $output[0]);
		unset($output[0]);
		$this->subject = implode(" ", $output);
		$this->subject = str_replace("  ", " ", $this->subject);
		unlink($filename);
	}

	// Find and return the patch with specified commit
	public static function get_by_commit($commit, $patches) {
		foreach($patches as $p) {
			if ($p->commit_id == $commit)
				return $p;
		}

		return FALSE;
	}

	// Return all patches in the work dir as an array
	public static function get_patches($patch_dir) {
		$files = get_patch_filenames($patch_dir);
		$patches = array();
		foreach ($files as $file) {
			$p = new Patch();
			$p->parse($file);
			$patches[] = $p;
		}

		return $patches;
	}

	// Returns the patch for the next commit to be processed from the log
	public static function get_next_in_log($log, $work_dir)
	{
		$patches = Patch::get_patches($work_dir."/patches");
		$next = $log->get_next_commit();
		$p = Patch::get_by_commit($next, $patches);

		return $p;
	}

	function get_mainline_tag($git)
	{
		$git->cmd("git tag --sort=version:refname --contains ".$this->commit_id, $res);

		if (count($res) > 1) {
			// Tag version is tricky since eg v5.6 gets sorted before v5.6-rc1
			// so we must adjust for this with some hackery.
			if (strpos($res[0], "-rc") === FALSE) {
				$str = $res[0]."-rc";
				$len = strlen($str);
				if (strncmp($res[1], $str, $len) == 0)
					return $res[1];
				else
					return $res[0];
			} else {
				return $res[0];
			}
		} else if (count($res) == 1) {
			return $res[0];
		} else {
			return FALSE;
		}
	}
}

class Log {
	var $filename = FALSE;
	var $head; // Backport setup data
	var $body; // Commits
	var $tail; // Postponed commits

	// Load the log from the work directory
	public function load($filename) {
		$this->filename = $filename;
		$tmp = file_get_contents($filename);
		if ($tmp === FALSE || strlen($tmp) == 0)
			return FALSE;

		$tmp = explode("---".PHP_EOL, $tmp);
		$this->head = $tmp[0];
		$this->body = $tmp[1];
		if (isset($tmp[2]))
			$this->tail = $tmp[2];
		else
			$this->tail = "";
	}

	// Save the log to the work directory
	public function save($filename = FALSE) {
		$contents  = $this->head."---".PHP_EOL.$this->body."---".PHP_EOL.$this->tail;
		if ($filename === FALSE)
			$filename = $this->filename;
		file_put_contents($filename, $contents);
	}

	public function get_head() { return $this->head; }
	public function append_head($str) { $this->head .= $str; }

	public function get_body() { return $this->body; }
	public function set_body($body) { $this->body = $body; }
	public function append_body($str) { $this->body .= $str; }

	public function append_patch($p) {
		$this->append_body("# ".$p->subject.PHP_EOL);
		$this->append_body($p->commit_id.PHP_EOL.PHP_EOL);
	}

	// Get the contents of a tag and store in $var
	private function get_tag($line, $tag, &$var) {
		$tag = strtolower($tag);
		if (strtolower(substr($line, 0, strlen($tag))) === $tag) {
			$tag = substr($line, strlen($tag));

			// Append to array if needed
			if (is_array($var))
				$var[] = $tag;
			else
				$var = $tag;
		}
	}

	// Find requested tag in head and return it
	public function get_head_tag($tag) {
		if ($this->filename === FALSE)
			return FALSE;

		$head = explode(PHP_EOL, $this->get_head());

		foreach($head as $line) {
			$this->get_tag($line, $tag.": ", $res);
		}
		
		return $res;
	}

	// Set backport commit id for specified upstream commit id
	public function update_commit($upstream_id, $backport_id) {
		if ($this->filename === FALSE)
			return FALSE;

		$body = explode(PHP_EOL, $this->get_body());

		// Find row
		for ($i = 0; $i < count($body); $i++) {
			$line = $body[$i];
			if (trim($line) == "")
				continue;

			$line = explode(" ", $line);
			if ($line[0] == "#")
				continue;
	
			if ($line[0] == $upstream_id) {
				$body[$i] = $upstream_id." ".$backport_id;
				break;
			}
		}

		if ($i == count($body))
			fatal("Couldn't find upstream commit: ".$upstream_id);

		$body = implode(PHP_EOL, $body);
		$this->set_body($body);
		$this->save();
	}

	// Return the latest applied commit from log as array [upstream_id, backport_id]
	public function get_last_commit() {
		$body = $this->get_body();
		$body = explode(PHP_EOL, $body);

		$prev_line = "";
		foreach ($body as $line) {
			if ($line == "")
				continue;
			$line = explode(" ", $line);
			if ($line[0] == "#")
				continue;
			if (count($line) == 1)
				return $prev_line;
			if ($line[1] == "")
				return $prev_line;

			$prev_line = $line;
		}

		return $prev_line;
	}

	// Find the next commit id to process from the commit log
	public function get_next_commit() {
		$body = $this->get_body();
		$body = explode(PHP_EOL, $body);

		foreach ($body as $line) {
			if ($line == "")
				continue;
			$line = explode(" ", $line);
			if ($line[0] == "#")
				continue;
			if (count($line) == 1)
				return $line[0];
			if ($line[1] == "")
				return $line[0];
		}
	}

	public function get_num_commits() {
		$body = $this->get_body();
		$body = explode(PHP_EOL, $body);

		$i = 0;
		foreach ($body as $line) {
			$line = explode(" ", $line);
			if (strlen($line[0]) == 40)
				$i++;
		}

		return $i;
	}

	public function get_commit_index($commit_id) {
		$body = $this->get_body();
		$body = explode(PHP_EOL, $body);

		$i = 0;
		foreach ($body as $line) {
			$line = explode(" ", $line);
			if ($line[0] == "#")
				continue;
			if ($line[0] == "")
				continue;

			if ($commit_id == $line[0])
				return $i;

			$i++;
		}

		return FALSE;
	}

	// Sanity check last entry in log
	function sanity_check_last($git) {
		// Sanity check log vs git-repo
		$last = $this->get_last_commit();
		if (isset($last[1]) && strlen($last[1]) == 40) {
			$p1 = new Patch(); // Upstream commit
			$p2 = new Patch(); // Backport commit
			$p1->parse_from_git($last[0], $git);
			$p2->parse_from_git($last[1], $git);
			if ($p1->subject != $p2->subject) {
				fatal("Commit log is corrupted. Must be fixed manually.\n(".
				      $p1->subject." != ".$p2->subject.")");
			}
		}
	}
}

class GitRepo {
	var $dir;

	public function set_dir($dir) { $this->dir = $dir; }
	public function get_dir() { return $this->dir; }

	// Run a shell command in the git repository directory
	public function cmd($cmd, &$output = FALSE, &$status = FALSE) {
		debug("git cmd: ".$cmd);
		exec("cd ".$this->dir." && ".$cmd, $output, $status);
	}

	// Returns the currently selected branch
	public function get_current_branch() {
		$this->cmd("git branch --show-current", $name);
		if (count($name) == 0)
			fatal("Failed to get current branch!");

		return $name[0];
	}

	// Returns the commit id of the latest committed patch
	public function get_current_commit_id() {
		$this->cmd("git rev-list HEAD~1..HEAD", $git_head);

		return $git_head[0];
	}

	public static function cmp_commits($a, $b) {
		$len = min(strlen($a), strlen($b));

		if (strncmp($a, $b, $len) == 0)
			return TRUE;

		return FALSE;
	}

	private function parse_status_paths($str, $line_skip) {
		$this->cmd("git status", $output);

		while (count($output) > 0 && $output[0] != $str)
			array_shift($output);

		// Parse the modified files from output
		$output = array_splice($output, $line_skip);
		$paths = array();
		foreach ($output as $o) {
			if ($o == "")
				break;
			$o = explode(":", $o);
			$paths[] = trim($o[1]);
		}

		return $paths;
	}

	// Returns an array of unmerged paths
	public function get_unmerged_paths() {
		return $this->parse_status_paths("Unmerged paths:", 3);
	}

	// Returns an array of paths to be commited
	public function get_modified_paths() {
		return $this->parse_status_paths("Changes to be committed:", 2);
	}

	// Returns an array of paths not staged for commit
	public function get_unstaged_paths() {
		return $this->parse_status_paths("Changes not staged for commit:", 2);
	}

	// Switch to a different git branch
	public function change_branch($log) {
		$range_start = $log->get_head_tag("range-start");
		$branch = $log->get_head_tag("branch");
		$branch_point = $log->get_head_tag("branch-point");

		if ($branch == "")
			fatal("Invalid branch. Did you run setup properly?");

		if ($this->get_current_branch() != $branch) {
			$this->cmd("git checkout ".$branch." 2> /dev/null", $output, $status);
			if ($status != 0)
				$this->cmd("git checkout -b ".$branch." ".$branch_point);
		}

		// Sanity check the branch
		if ($this->get_current_branch() != $branch)
			fatal("Couldn't create/find correct branch");
	}

	// Find where in the patch series we currently are
	public function find_commit_index($commit, $patches) {
		$num = count($patches);
		for ($i = 0; $i < $num; $i++) {
			if ($commit == $patches[$i]->commit_id) {
				break;
			}
		}

		// If commit is not found we start from beginning (index 0)
		if ($i == $num)
			$i = 0;

		return $i;
	}

	public function skip_commit($log, $p, $reason) {
		$this->cmd("git am --skip");
		$log->update_commit($p->commit_id, $reason);
	}

	public function check_for_conflicts() {
		// Check that none of the unmerged paths still contain conflicts
		$unmerged = $this->get_unmerged_paths();
		$conflicts = FALSE;

		foreach ($unmerged as $u) {
			$this->cmd("grep -Hn \"<<<<<<\" ".$u, $res);
			if (count($res) > 0)
				$conflicts = TRUE;
			$this->cmd("grep -Hn \"======\" ".$u, $res);
			if (count($res) > 0)
				$conflicts = TRUE;
			$this->cmd("grep -Hn \">>>>>>\" ".$u, $res);
			if (count($res) > 0)
				$conflicts = TRUE;
		}

		return $conflicts;
	}

	public function check_am_session() {
		$this->cmd("git status", $res);
		if ($res[1] == "You are in the middle of an am session.")
			return TRUE;
		else
			return FALSE;
	}

	function check_for_cherry_pick($log, $p)
	{
		// Check if patch is already cherry picked
		$range_start = $log->get_head_tag("range-start");
		$this->cmd("git log ".$range_start."~".CHERRY_PICK_HISTORY.
			   "..".$range_start." -n1 --oneline --grep=\"cherry picked from commit ".
			   $p->commit_id."\"", $res);

		if (count($res) > 0) {
			info("Found i915 cherry-pick (".$res[0].")");
			$res = explode(" ", $res[0]);
			return $res[0];
		}

		unset($res);
		$this->cmd("git rev-list --no-merges -n1 --oneline HEAD --grep \"".
			  addslashes($p->subject)."\"", $res);

		if (count($res) > 0) {
			$commit_id = explode(" ", $res[0])[0];
			$res = explode(" ", $res[0]);
			unset($res[0]);
			$subject = implode(" ", $res);

			if (!GitRepo::cmp_commits($commit_id, $p->commit_id) &&
						  $subject == $p->subject) {
				info("Found cherry-pick (".$commit_id.")");
				return $commit_id;
			}
		}

		return FALSE;
	}

	public function get_backported_commits($log) {
		$start = $log->get_head_tag("range-start");
		$branch = $log->get_head_tag("branch");
		$this->cmd("git rev-list --reverse ".$start."..".$branch, $res);

		return $res;
	}
}

function array_to_str($array)
{
	$out = "";
	foreach($array as $line)
		$out .= $line."\n";

	return $out;
}

// Returns filenames for all the exported patches
function get_patch_filenames($dir)
{
	$dir = realpath($dir);
	exec("find ".$dir."| sort | grep \"\\.patch\"", $files);

	return $files;
}

function get_opt($name, $opts)
{
	$opt = isset($opts[$name]) ? $opts[$name] : "";
	if ($opt == "")
		fatal("Missing --".$name." <arg>");

	return $opt;
}

function launch_editor($unmerged, $p, $log, $git, $work_dir)
{
	$solutions = "";
	foreach ($unmerged as $i => $u) {
		// Figure out the extension so that the editor can do syntax highlighting
		$info = pathinfo($u);
		$file_ext = isset($info['extension']) ? $info['extension'] : "";
		if ($file_ext != "")
			$file_ext = ".".$file_ext;
		$solution_name = "solution-tmp".$file_ext;

		// Store the target version of the file (eg git show v5.5:<filename>)
		$git->cmd("git show ".$log->get_head_tag("Range-stop").":".$u." | ".
			"dd of=".$work_dir."/".$solution_name." 2> /dev/null", $output, $status);

		// Add the entire path to modified files
		$u = $git->get_dir()."/".$u;

		// Find line number for first conflict
		$res = "";
		$git->cmd("grep -n \"<<<<<<\" ".$u, $res);
		if (count($res) > 0) {
			$res = explode(":", $res[0]);
			$line_no = " +".$res[0];
		} else {
			$line_no = "";
		}

		// Open vim with all the relevant files
		passthru("vim -O ".$line_no." ".$u." ".$work_dir."/".$solution_name." ".$p->filename." 2> /dev/null");

		exec("rm ".$work_dir."/".$solution_name);
	}
}

function cmd_export($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$start = $log->get_head_tag("range-start");
	$stop = $log->get_head_tag("range-stop");
	$git_dir = $log->get_head_tag("git-dir");
	$paths = $log->get_head_tag("paths");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	// Execute git format-patch
	echo "Exporting patches...";

	exec("mkdir -p ".$work_dir."/patches/");
	$git->cmd("git format-patch --no-renames --topo-order --keep-subject --no-merges -o ".
		 $work_dir."/patches/ ".$start."..".$stop." ".$paths);

	$log->set_body("#         <Upstream commit id>".
		       "                   <Backported commit id>\n");
	$files = get_patch_filenames($work_dir."/patches");
	$patches = array();
	foreach ($files as $file) {
		$p = new Patch();
		$p->parse($file);
		$patches[] = $p;
		$log->append_patch($p);
	}

	$log->save($work_dir."/commits.log");

	echo count($files)."\n";
	exit();
}

function cmd_apply($argv, $opts)
{
	global $progname;

	$work_dir = realpath(get_opt("work-dir", $opts));
	$force = isset($opts['force']) ? TRUE : FALSE;

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	$git_dir = $log->get_head_tag("git-dir");
	$range_start = $log->get_head_tag("range-start");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$patches = Patch::get_patches($work_dir."/patches");

	$num_patches = count($patches);
	if ($num_patches == 0)
		fatal("No patches to apply. Did you forget to run export?");

	$log->sanity_check_last($git);

	$next_commit = $log->get_next_commit();
	$i = $git->find_commit_index($next_commit, $patches);
	for (; $i < $num_patches; $i++) {
		$p = $patches[$i];

		// Check if we're in an am session
		if ($git->check_am_session()) {
			$unmerged = $git->get_unmerged_paths();
			$unstaged = $git->get_unstaged_paths();

			if (count($unmerged) > 0 || count($unstaged) > 0) {
				error("Repository contains unmerged/unstaged paths. Solve conflict before continuing.");
				launch_editor($unmerged, $p, $log, $git, $work_dir);

				// If all conflicts are fixed we automatically add them
				// User can also force the changes even with conflicts by adding the --force option
				if ($git->check_for_conflicts() == FALSE) {
					cmd_add($argv, $opts);
				} else {
					error("Unmerged paths still contain conflicts");
					if ($force == TRUE) {
						info("Force adding since --force was specified. Rerun apply to continue.");
						cmd_add($argv, $opts);
					} else {
						msg("Add option --force to add all files anyway");
					}
				}

				exit(1);
			}

			if (count($git->get_modified_paths()) > 0) {
				debug("In AM session with modified paths. git am --contine");
				$git->cmd("git am --continue");

				$last_id = $git->get_current_commit_id();
				$log->update_commit($p->commit_id, $last_id);
				green("Applied\t(".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
			} else {
				debug("In AM session WITHOUT modified paths. git am --skip");
				$git->cmd("git am --skip");
				$log->update_commit($p->commit_id, "empty");
				info("Empty\t(".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
			}

			continue;
		}

		$filename = $p->filename;
		$output_am = "";

		$old_id = $git->get_current_commit_id();
		$git->cmd("git am --3way ".$filename." 2> /dev/stdout", $output_am, $status);
		$new_id = $git->get_current_commit_id();

		// Check if patch did not apply
		if ($status != 0) {
			// Save git am output to file so we can show it in edit (vim, emacs, etc.)
			file_put_contents($work_dir."/output.tmp", array_to_str($output_am));

			$cherry_id = $git->check_for_cherry_pick($log, $p);
			if ($cherry_id !== FALSE) {
				info("Cherry picked (".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
				$log->update_commit($p->commit_id, "cherry-picked-by ".$cherry_id);
				$git->cmd("git am --abort");
				continue;
			}

			delimiter();
			echo "Unmerged paths:\n";
			$unmerged = $git->get_unmerged_paths();
			error(array_to_str($unmerged));

			delimiter();
			error("Failed patch: ".basename($p->filename));

			delimiter();
			echo "Fix conflict and rerun apply.\n";
			info("(IMPORTANT! Do NOT run: git am --continue)");

			launch_editor($unmerged, $p, $log, $git, $work_dir);

			// If all conflicts are fixed we automatically add them
			if ($git->check_for_conflicts() == FALSE) {
				cmd_add($argv, $opts);
				exit(0);
			} else {
				error("Unmerged paths still contain conflicts");
			}

			exit(1);
		}

		// Patch might not have introduced changes thus did not get applied (not needed)
		if ($old_id == $new_id) {
			$cherry_id = $git->check_for_cherry_pick($log, $p);
			if ($cherry_id !== FALSE) {
				info("Cherry picked (".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
				$log->update_commit($p->commit_id, "cherry-picked-by ".$cherry_id);
				continue;
			}

			info("Empty\t(".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
			$log->update_commit($p->commit_id, "empty");
			continue;
		}
		$log->update_commit($p->commit_id, $new_id);
		green("Applied (".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
	
/*
		$git->cmd("make -j16 M=drivers/gpu/drm 2> /dev/null", $res, $status);
		if ($status != 0)
			error("Compilation failed!");
*/
	}

	exit();
}

function cmd_setup($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));
	$branch = get_opt("branch", $opts);
	$branch_point = get_opt("branch-point", $opts);
	$range_start = get_opt("start", $opts);
	$range_stop = get_opt("stop", $opts);
	$git_dir = realpath(get_opt("git-dir", $opts));
	$paths = get_opt("paths", $opts);

	$log = new Log();
	$log->append_head("Range-start: ".$range_start."\n");
	$log->append_head("Range-stop: ".$range_stop."\n");
	$log->append_head("Branch: ".$branch."\n");
	$log->append_head("Branch-point: ".$branch_point."\n");
	$log->append_head("Git-dir: ".$git_dir."\n");
	$log->append_head("Paths: ".$paths."\n");

	$log->save($work_dir."/commits.log");

	info("Setup saved to ".$work_dir."/commits.log");
	exit(0);
}

function cmd_add($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));
	$force = isset($opts['force']) ? TRUE : FALSE;

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$fatal = $git->check_for_conflicts();
	if ($fatal && $force == FALSE)
		fatal("Unmerged paths still contain conflicts!");

	$unmerged = $git->get_unmerged_paths();
	foreach ($unmerged as $u) {
		$git->cmd("git add ".$u);
	}

	$modified = $git->get_modified_paths();
	echo "Added files:\n";
	foreach ($modified as $m) {
		green("\t".$m);
	}

	exit(0);
}

function cmd_restart($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);
	$branch = $log->get_head_tag("branch");

	if ($git->check_am_session()) {
		$git->cmd("git am --abort");
	}

	$git->cmd("git checkout master");
	$git->cmd("git branch -D ".$branch);

	$log->set_body("");
	$files = get_patch_filenames($work_dir."/patches");
	$patches = array();
	foreach ($files as $file) {
		$p = new Patch();
		$p->parse($file);
		$patches[] = $p;
		$log->append_patch($p);
	}

	$log->save($work_dir."/commits.log");

}

function cmd_skip($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$modified = $git->get_modified_paths();
	if (count($modified) > 0)
		fatal("You have modified paths. Cannot skip!");

	$git->cmd("git am --abort");

	$p = Patch::get_next_in_log($log, $work_dir);
	$num_patches = count(Patch::get_patches($work_dir."/patches"));

	$cherry_id = $git->check_for_cherry_pick($log, $p);
	if ($cherry_id !== FALSE) {
		info("Cherry picked (?/".$num_patches.") ".$p->commit_id." ".$p->subject);
		$log->update_commit($p->commit_id, "cherry-picked-by ".$cherry_id);
		return;
	}

	info("Manual skip (?/".$num_patches.") ".$p->commit_id." ".$p->subject);
	$log->update_commit($p->commit_id, "manual-skip");

	cmd_apply($argv, $opts);
}

function cmd_sanity_check($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));
	$fix = isset($opts['fix']) ? TRUE : FALSE;

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$range_start = $log->get_head_tag("range-start");
	$range_stop = $log->get_head_tag("range-stop");
	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$body = $log->get_body();
	$body = explode(PHP_EOL, $body);

	$backported = $git->get_backported_commits($log);

	$i = 0;
	$j = 0;
	$num_faults = 0;
	$num_fixed = 0;
	foreach ($body as $line) {
		$i++;
		$line = explode(" ", $line);
		if ($line == "")
			continue;
		if ($line[0] == "")
			continue;
		if ($line[0][0] == "#")
			continue;
		if (!isset($line[1]) || $line[1] == "")
			continue;
		if (strlen($line[1]) != 40 && $line[1] != "empty")
			continue;

		$p1 = new Patch(); // Upstream commit
		$p1->parse_from_git($line[0], $git);

		if ($line[1] == "empty") {
			debug("Processing empty: ". $p1->commit_id." ".$p1->subject);
			$res = NULL;
			$git->cmd("git rev-list --no-merges -n1 --oneline HEAD --grep \"".
				  addslashes($p1->subject)."\"", $res);

			if (count($res) == 0)
				continue;

			$commit_id = explode(" ", $res[0])[0];
			$res = explode(" ", $res[0]);
			unset($res[0]);
			$subject = implode(" ", $res);
				
			if (!GitRepo::cmp_commits($commit_id, $p1->commit_id) &&
			    $subject == $p1->subject) {
				info("Found cherry-pick: ".$commit_id." ".$subject);

				if ($fix === TRUE) {
					info("Fixing: Change empty into cherry pick");
					$log->update_commit($p1->commit_id, "cherry-picked-by ".$commit_id);
					$num_fixed++;
				}
			}
			continue;
		}

		$p2 = new Patch(); // Backport commit
		$p2->parse_from_git($line[1], $git);
		// info("\"".$p1->subject."\" == \"".$p2->subject."\"");

		$bp_id = $backported[$j];
		$p3 = new Patch();
		$p3->parse_from_git($bp_id, $git);

		// HACK: Sometimes there are double spaces in some subjects.
		// They must be removed before comparing

		$p1->subject = str_replace("  ", " ", $p1->subject);
		$p2->subject = str_replace("  ", " ", $p2->subject);
		$p3->subject = str_replace("  ", " ", $p3->subject);

		debug("i=".$i." j=".$j);
		debug("Upstream\t".$p1->commit_id." ".$p1->subject);
		debug("In log\t\t".$p2->commit_id." ".$p2->subject);
		debug("In repo\t\t".$p3->commit_id." ".$p3->subject);

		if ($p1->commit_id == $p2->commit_id)
			fatal("Comparing the same commit. This shouldn't happen!");

		if ($p1->subject != $p2->subject) {
			error("Commit log is inconsistent at commit: ".$i);
			echo "\t".$p1->commit_id." ".$p1->subject."\n".
			     "\t".$p2->commit_id." ".$p2->subject."\n";
			$num_faults++;
		}

		if ($p2->commit_id != $bp_id) {
			error("Found non-matching log vs git repo commit");
			$num_faults++;

			// Check if rebase must have happened
			if ($p1->subject == $p2->subject && $p1->subject == $p3->subject) {
				// Looks like a problem we can fix
				if ($fix == TRUE) {
					info("Fixing: Updating rebased commit id: ".$p1->commit_id);
					$log->update_commit($p1->commit_id, $p3->commit_id);
					$num_fixed++;
				}
			} else {
				error("Our commit log is out of sync with git log!");
				if ($fix == TRUE) {
					error("Cannot continue, aborting FIX session!");
					return;
				}
			}
		}

		$j++;
	}

	msg("Processed ".$j." commits");
	if ($num_faults == 0)
		green("Found ".$num_faults." problems");
	else
		error("Found ".$num_faults." problems");

	if ($fix == TRUE)
		info("Fixed ".$num_fixed." commits");
}


function cmd_rebase($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$range_start = $log->get_head_tag("range-start");
	$range_stop = $log->get_head_tag("range-stop");
	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$body = $log->get_body();
	$body = explode(PHP_EOL, $body);

	$backported = $git->get_backported_commits($log);

	$i = 0;
	$j = 0;
	$num_faults = 0;
	$num_fixed = 0;
	foreach ($body as $line) {
		$i++;
		$line = explode(" ", $line);
		if ($line == "")
			continue;
		if ($line[0] == "")
			continue;
		if ($line[0][0] == "#")
			continue;
		if (!isset($line[1]) || $line[1] == "")
			continue;
		if (strlen($line[1]) != 40 && $line[1] != "empty")
			continue;

		$p1 = new Patch(); // Upstream commit
		$p1->parse_from_git($line[0], $git);

		if ($line[1] == "empty")
			continue;

		$p2 = new Patch(); // Backport commit
		$p2->parse_from_git($line[1], $git);

		$bp_id = $backported[$j];
		$p3 = new Patch();
		$p3->parse_from_git($bp_id, $git);

		// HACK: Sometimes there are double spaces in some subjects.
		// They must be removed before comparing

		$p1->subject = str_replace("  ", " ", $p1->subject);
		$p2->subject = str_replace("  ", " ", $p2->subject);
		$p3->subject = str_replace("  ", " ", $p3->subject);

		debug("i=".$i." j=".$j);
		debug("Upstream\t".$p1->commit_id." ".$p1->subject);
		debug("In log\t\t".$p2->commit_id." ".$p2->subject);
		debug("In repo\t\t".$p3->commit_id." ".$p3->subject);

		if ($p1->commit_id == $p2->commit_id)
			fatal("Comparing the same commit. This shouldn't happen!");

		if ($p1->subject != $p2->subject) {
			error("Commit log is inconsistent at commit: ".$i);
			echo "\t".$p1->commit_id." ".$p1->subject."\n".
			     "\t".$p2->commit_id." ".$p2->subject."\n";
			$num_faults++;
		}

		if ($p2->commit_id != $bp_id) {
			$num_faults++;

			// Check if rebase must have happened
			if ($p1->subject == $p2->subject && $p1->subject == $p3->subject) {
				// Looks like a problem we can fix
				info("Rebasing commit id: ".$p1->commit_id);
				$log->update_commit($p1->commit_id, $p3->commit_id);
				$num_fixed++;
			} else {
				error("Our commit log is out of sync with git log!");
				if ($fix == TRUE) {
					error("Cannot continue, aborting rebase session!");
					return;
				}
			}
		}

		$j++;
	}

	msg("Processed ".$j." commits");
	info("Rebased ".$num_fixed." commits");
}

function cmd_diffstat($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$range_stop = $log->get_head_tag("range-stop");
	$paths = $log->get_head_tag("paths");
	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$res = FALSE;
	$git->cmd("git diff --stat ".$branch." ".$range_stop." ".$paths, $res, $status);
	if ($status != 0)
		fatal("Failed to diff");

	echo array_to_str($res);
}

function cmd_status($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$range_stop = $log->get_head_tag("range-stop");
	$paths = $log->get_head_tag("paths");
	$git_dir = $log->get_head_tag("git-dir");
	$branch = $log->get_head_tag("branch");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$last_commit = $log->get_last_commit();
	$last_commit = $last_commit[0];
	$last_num = $log->get_commit_index($last_commit) + 1;
	$num_commits = $log->get_num_commits();

	echo "Progress ".(round(($last_num / $num_commits) * 100, 0))."% (".$last_num."/".$num_commits." commits)\n";

	$res = FALSE;
	$git->cmd("git diff --stat ".$branch." ".$range_stop." ".$paths, $res, $status);
	if ($status != 0)
		fatal("Failed to diff");

	$last_line = count($res) - 1;
	msg(trim($res[$last_line])."\n");


	if ($last_num >= $num_commits) {
		msg("Backport is done!");
		return;
	}

	$next_commit = $log->get_next_commit();
	$patches = Patch::get_patches($work_dir."/patches");
	$p = Patch::get_by_commit($next_commit, $patches);

	if ($git->check_am_session())
		echo "In AM session on commit:\n";
	else
		echo "Not in AM session. Next commit:\n";
	echo $p->commit_id." ".$p->subject."\n";

	$unmerged = $git->get_unmerged_paths();
	$unstaged = $git->get_unstaged_paths();
	$modified = $git->get_modified_paths();

	if (count($modified) > 0) {
		echo "Modified:\n";
		foreach ($modified as $m) {
			green("\t".$m);
		}
	}

	if (count($unstaged) > 0) {
		echo "Unstaged:\n";
		foreach ($unstaged as $u) {
			green("\t".$u);
		}
	}

	if (count($unmerged) > 0) {
		echo "Unmerged:\n";
		foreach ($unmerged as $u) {
			error("\t".$u);
		}
	}

	echo "\n";
}

function cmd_diff($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$range_stop = $log->get_head_tag("range-stop");
	$paths = $log->get_head_tag("paths");
	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$git->cmd("git diff ".$branch." ".$range_stop." ".$paths, $res, $status);
	if ($status != 0)
		fatal("Failed to diff");

	echo array_to_str($res);
	delimiter();

	$res = FALSE;
	$git->cmd("git diff --stat ".$branch." ".$range_stop." ".$paths, $res, $status);
	if ($status != 0)
		fatal("Failed to diff");

	echo array_to_str($res);
}

function cmd_postpone($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	if ($git->check_am_session()) {
		$git->cmd("git am --abort");
	}

	$branch = $log->get_head_tag("branch");
	$git->change_branch();

}

function cmd_log($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$body = $log->get_body();
	$body = explode(PHP_EOL, $body);

	for ($i = 0; $i < count($body); $i++) {
		$line = explode(" ", $body[$i]);
		if (strlen($line[0]) == 40 && strlen($line[1]) == 40) {
			$p = new Patch();
			$p->parse_from_git($line[0], $git);

			echo $line[0]." ".$p->subject."\n";
		}
	}
}

function suse_format_patch($p1, $p2, $signoff, $refs, $git)
{
	$mainline = $p2->get_mainline_tag($git);
	if ($mainline === FALSE)
		fatal("Couldn't find mainline tag for ".$p2->commit_id." ".$p2->subject);

	$data = file_get_contents($p1->filename);
	$data = explode(PHP_EOL, $data);

	$tags = array(	"Git-commit: ".$p2->commit_id,
			"Patch-mainline: ".$mainline,
			"References: ".$refs);

	// Find appropriate position for tags
	for ($i = 0; $i < count($data); $i++) {
		$str = "Content-Transfer-Encoding: ";
		if (strncmp($str, $data[$i], strlen($str)) == 0)
			break;
	}

	// If above tag is not found, try the subject tag
	if ($i == count($data)) {

		// Find index for subject tag
		for ($i = 0; $i < count($data); $i++) {
			$str = "Subject: ";
			if (strncmp($str, $data[$i], strlen($str)) == 0)
				break;
		}
	}

	if ($i == count($data))
		fatal("Couldn't find subject tag in patch");

	array_splice($data, ($i + 1), 0, $tags);

	$data = implode(PHP_EOL, $data);

	$data = explode(PHP_EOL."---".PHP_EOL, $data);
	$data[0] = $data[0].PHP_EOL."Signed-off-by: ".$signoff;
	$data = implode(PHP_EOL."---".PHP_EOL, $data);

	file_put_contents($p1->filename, $data);
}

function cmd_format_suse($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));
	$start = get_opt("start", $opts);
	$stop = get_opt("stop", $opts);
	$signoff = get_opt("signoff", $opts);
	$refs = get_opt("refs", $opts);

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	// $start = $log->get_head_tag("range-start");
	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	exec("mkdir -p ".$work_dir."/patches-suse");
	exec("rm ".$work_dir."/patches-suse/*");

	info("Exporting patches...");
	$git->cmd("git format-patch -o ".$work_dir."/patches-suse/ --no-renames --keep-subject ".$start."..".$stop);

	$body = $log->get_body();
	$body = explode(PHP_EOL, $body);

	info("Formatting patches...");
	$patches = Patch::get_patches($work_dir."/patches-suse");
	$suse_filenames = "./scripts/git_sort/series_insert.py ";
	for ($i = 0, $j = 0; $i < count($body); $i++) {
		$line = explode(" ", $body[$i]);
		if (strlen($line[0]) == 40 && strlen($line[1]) == 40) {
			if (!isset($patches[$j]))
				fatal("More patches in log than in backport!");

			// We get more correct subject lines when parsing from git so do that here
			$p_file = $patches[$j];

			$p1 = new Patch();
			$p1->parse_from_git($p_file->commit_id, $git);

			$p2 = new Patch();
			$p2->parse_from_git($line[0], $git);

			if ($p1->subject != $p2->subject)
				error("Subject not matching\n".$p1->subject." != ".$p2->subject);

			suse_format_patch($p_file, $p2, $signoff, $refs, $git);
			msg("(".($j + 1)."/".count($patches).") ".$p2->commit_id." ".$p2->subject);

			$suse_filenames .= "patches.suse/".basename($p_file->filename)." ";
			$j++;
		}
	}

	file_put_contents($work_dir."/patches-suse/suse_sort.sh", $suse_filenames);
}

function cmd_list_cherry_picks($argv, $opts)
{
	$work_dir = realpath(get_opt("work-dir", $opts));

	$log = new Log();
	$log->load($work_dir."/commits.log");

	$branch = $log->get_head_tag("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$git_dir = $log->get_head_tag("git-dir");

	$git = new GitRepo();
	$git->set_dir($git_dir);

	$git->change_branch($log);

	$body = $log->get_body();
	$body = explode(PHP_EOL, $body);
	foreach ($body as $line) {
		$line = explode(" ", $line);
		if (count($line) < 3)
			continue;
		if ($line[1] != "cherry-picked-by")
			continue;

		$p1 = new Patch();
		$p1->parse_from_git($line[0], $git);
		$p2 = new Patch();
		$p2->parse_from_git($line[2], $git);

		if ($p1->subject != $p2->subject)
			error("Subjects doesn't match");

		msg($line[0]." # Duplicate of ".$p2->commit_id.": ".$p2->subject);
	}
}

function parse_options($argv)
{
	$opts = array(
		"start:",
		"stop:",
		"branch:",
		"branch-point:",
		"work-dir:",
		"git-dir:",
		"paths:",
		"signoff:",
		"refs:",
		"fix",
		"force",
		"debug",
		);

	$options = getopt("", $opts, $optind);

	if (isset($argv[$optind]))
		$command = $argv[$optind];
	else
		return;

	if (isset($options["debug"]))
		define("DEBUG", TRUE);
	else
		define("DEBUG", FALSE);

	switch($command) {
	case "setup":
		cmd_setup($argv, $options);
		exit(0);
	case "export":
		cmd_export($argv, $options);
		exit(0);
	case "apply":
		cmd_apply($argv, $options);
		exit(0);
	case "skip":
		cmd_skip($argv, $options);
		exit(0);
	case "add":
		cmd_add($argv, $options);
		exit(0);
	case "restart":
		cmd_restart($argv, $options);
		exit(0);
	case "sanity-check":
		cmd_sanity_check($argv, $options);
		exit(0);
	case "status":
		cmd_status($argv, $options);
		exit(0);
	case "diffstat":
		cmd_diffstat($argv, $options);
		exit(0);
	case "diff":
		cmd_diff($argv, $options);
		exit(0);
	case "postpone":
		cmd_postpone($argv, $options);
		exit(0);
	case "rebase":
		cmd_rebase($argv, $options);
		exit(0);
	case "log":
		cmd_log($argv, $options);
		exit(0);
	case "format-suse":
		cmd_format_suse($argv, $options);
		exit(0);
	case "list-cherry-picks":
		cmd_list_cherry_picks($argv, $options);
		exit(0);
	}
}

parse_options($argv);

?>

Usage: <?= $progname ?> <options> <command>

ALL commands require --work-dir to be specified!

Commands:
  setup - Setup all backporting parameters
    --start=<range-start>
    --stop=<range-stop>
    --branch=<name-of-branch-to-do-backport-in>
    --work-dir=<working-directory>
    --git-dir=<git-repository-directory>
    --paths=<paths-in-git-repo-to-backport>
    Example:
    <?= $progname ?> \
      --start=v5.4 --stop=v5.5 --branch=my-backport \
      --work-dir=./empty-dir --git-dir=./linux-git \
      --paths="include/drm/ drivers/gpu/drm/" \
      setup

  export - Runs git-format-patch over the specified range

  apply - Start re-applying the series

  diff- Show diff between current tree vs target tree

  status- Show current status of backport and git repo

Examples:
	Create series of patches (git format-patch)
	<?= $argv[0] ?> get-series

