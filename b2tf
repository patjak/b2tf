#!/usr/bin/php
<?php
require_once("util.php");
require_once("storage.php");
require_once("options.php");
require_once("suse-fixes.php");
// How long back in commit history we check for cherry picks
define("CHERRY_PICK_HISTORY", 4000);

function msg($msg) { echo $msg."\n"; }
function fatal($msg) { echo "\e[31m".$msg."\e[0m\n"; if (Globals::$debug) { debug_print_backtrace(); } exit(1); }
function error($msg) { echo "\e[31m".$msg."\e[0m\n"; }
function info($msg) { echo "\e[36m".$msg."\e[0m\n"; }
function green($msg) { echo "\e[32m".$msg."\e[0m\n"; }
function debug($msg) { if (Globals::$debug) { echo "\e[33m".$msg."\e[0m\n"; } }
function debug_git($msg) { if (Globals::$debug_git) { echo "\e[33m".$msg."\e[0m\n"; } }
function delimiter() { echo "\e[33m----------\e[0m\n"; }

class Globals {
	public static	$log = FALSE,
			$git,
			$debug = FALSE,
			$debug_git = FALSE;
};

/**
 * A representation of a patch file
 */
class Patch {
	var $filename;			///< Full path to the patch file
	var $commit_id;			///< The git commit hash
	var $author;			///< Author of the patch
	var $date;			///< Patch date
	var $subject;			///< Patch subject
	var $signatures = array();	///< Array of signed-off-by tags
	var $reviews = array();		///< Array of reviewied-by tags
	var $cherry_pick;		///< Is the patch a cherry pick?
	var $references = "";		///< SUSE References

	/**
	 * Get the contents of a tag and store in $var. $tag is not case sensitive
	 *
	 * @param $line	The line in the patch file to search (haystack)
	 * @param $tag	The tag to search for in the line (needle)
	 * @param $var	Used to return the found tag (if any is found)
	 */
	private function get_tag($line, $tag, &$var) {
		$line = trim($line);
		if (substr($line, 0, strlen($tag)) === $tag) {
			$tag = substr($line, strlen($tag));

			// Append to array if needed
			if (is_array($var))
				$var[] = $tag;
			else
				$var = $tag;
				
		}
	}

	/**
	 * Search the patch for specified tag and return it's value if found
	 *
	 * @param $tag	The tag we're looking for
	 *
	 * @return Returns the value of the specified tag or FALSE if not found
	 */
	public function parse_for_tag($tag) {
		$file = file_get_contents($this->filename);
		$var = FALSE;

		$lines = explode(PHP_EOL, $file);
		foreach ($lines as $line) {
			$this->get_tag($line, $tag, $var);
			if ($var !== FALSE)
				break;
		}

		return $var;
	}

	/**
	 * Parse contents of patch file and store in Patch object.
	 *
	 * @param $filename Full path filename to the patch file
	 */
	public function parse($filename) {
		$file = file_get_contents($filename);
		$file = explode("---".PHP_EOL, $file);
		$head = $file[0];

		$head = explode(PHP_EOL, $head);

		// Patch format and git format are different
		if (isset($file[1])) {
			// Patch format
			$body = $file[1];
		} else {
			// Git format
			$body = "";
		}

		// First line is always commit id
		$commit_id = array_shift($head);
		$commit_id = explode(" ", $commit_id);
		$this->commit_id = $commit_id[1];

		// Parse rest of head
		foreach($head as $line) {
			$this->filename = realpath($filename);
			$this->get_tag($line, "From: ", $this->author);
			$this->get_tag($line, "Date: ", $this->date);
			$this->get_tag($line, "Subject: ", $this->subject);
			$this->get_tag($line, "Signed-off-by: ", $this->signatures);
			$this->get_tag($line, "Reviewed-by: ", $this->reviews);
			$this->get_tag($line, "(cherry picked from commit ", $this->cherry_pick);

			// This is a hack but we only care about the first occurance of the tag references
			if ($this->references == "")
				$this->get_tag($line, "References: ", $this->references);
		}

		$this->subject = str_replace("  ", " ", $this->subject);

		$this->cherry_pick = substr($this->cherry_pick, 0, -1);
	}

	/**
	 * Read out patch header (body not included) from git commit
	 *
	 * @param $commit_id	Hash of commit to process
	 */
	public function parse_from_git($commit_id) {
		$git = Globals::$git;
		$filename = "/tmp/tmp-patch.tmp";

		$git->cmd("git log -n1 ".$commit_id." 2> /dev/null", $output, $status);
		if ($status != 0)
			return FALSE;

		$output = implode(PHP_EOL, $output);
		file_put_contents($filename, $output);
		$this->parse($filename);

		// We don't get the subject when parsing a git commit so do it manually here
		$git->cmd("git log --oneline -n1 ".$commit_id, $output);
		$output = explode(" ", $output[0]);
		unset($output[0]);
		$this->subject = implode(" ", $output);
		$this->subject = str_replace("  ", " ", $this->subject);
		unlink($filename);

		return TRUE;
	}

	/**
	 * Find and return the patch with specified commit
	 *
	 * @param $commit Commit hash to search for
	 * @param $patches Array of all patches
	 * @return The Patch object with the specified hash or FALSE on failure
	 */
	public static function get_by_commit($commit, $patches) {
		foreach($patches as $p) {
			if ($p->commit_id == $commit)
				return $p;
		}

		return FALSE;
	}

	/**
	 * @param $patch_dir Path to directory containing all exported patch files
	 * @return All patches in the specified directory as an array of Patch objects
	 */
	public static function get_patches($patch_dir) {
		$files = get_patch_filenames($patch_dir);
		$patches = array();
		foreach ($files as $file) {
			$p = new Patch();
			$p->parse($file);
			$patches[] = $p;
		}

		return $patches;
	}

	/**
	 * Find the patch for the next commit to process
	 *
	 * @param $log		The log object to process
	 * @param $work_dir	The directory where the exported patches are located
	 * @return The patch for the next commit to be processed from the Log
	 */
	public static function get_next_in_log($log, $work_dir)
	{
		$patches = Patch::get_patches($work_dir."/patches");
		$next = $log->get_next_commit();
		$p = Patch::get_by_commit($next, $patches);

		return $p;
	}

	/**
	 * Return the name of the next upcoming release (could be wrong ofc)
	 *
	 * @param $git The GitRepo object to use for processing
	 * @return Release name
	 */
	public static function get_next_tagged_release()
	{
		$git = Globals::$git;
		$git->cmd("git tag --sort=taggerdate | tail -1", $res);

		if (count($res) != 1)
			return FALSE;

		$tag = $res[0];

		if (strpos($tag, "-rc") === FALSE) {
			$tag = explode(".", $tag);
			$major = $tag[0];
			$minor = (int)$tag[1] + 1;
			$new_tag = $major.".".$minor;
			$new_tag .= "-rc1";
		} else {
			$rc = explode("-rc", $tag)[1];
			$new_tag = substr($tag, 0, -strlen($rc));
			$new_tag .= (int)$rc + 1;
		}

		return $new_tag;
	}

	/**
	 * Parse the mainline tag version of the Patch object
	 *
	 * @return The tag version of the Patch (ie. v5.4-rc3)
	 */
	function get_mainline_tag(&$version_list = array())
	{
		$git = Globals::$git;
		$git->cmd("git tag --sort=version:refname --contains ".$this->commit_id, $res);

		// Provide a list of all tags containing the commit
		$version_list = $res;

		if (count($res) > 1) {
			// Tag version is tricky since eg v5.6 gets sorted before v5.6-rc1
			// so we must adjust for this with some hackery.
			if (strpos($res[0], "-rc") === FALSE) {
				$str = $res[0]."-rc";
				$len = strlen($str);
				if (strncmp($res[1], $str, $len) == 0)
					return $res[1];
				else
					return $res[0];
			} else {
				return $res[0];
			}
		} else if (count($res) == 1) {
			return $res[0];
		} else {
			error("Failed to find mainline tag for: ".$this->commit_id);
			$next_tag = self::get_next_tagged_release();
			$ask = Util::ask("Use ".$next_tag."? (Y)es, (n)o, (s)kip: ", array("y", "n", "s"), "y");

			if ($ask == "y")
				return $next_tag;

			if ($ask == "n") {
				$mainline = Util::get_line("Enter tag manually or leave empty to skip patch: ");
				if (trim($mainline) == "")
					return FALSE;
				else
					return $mainline;
			}

			if ($ask == "s")
				return FALSE;
		}
	}
}

/**
 * A representation of the commit log
 *
 * The log serves two purposes. The first is to contain a complete list of all the commits we're
 * backporting. The second is to keep track of the upstream commit id of the backported patch.
 */
class Log {
	var $filename = FALSE;	///< Full path to the log file
	var $head;		///< Contains the configuration of the backport
	var $body;		///< The list of commits for the backport
	var $tail;		///< Postponed commits (wip)

	/**
	 * Load the log from the work directory into the Log object
	 *
	 * @param $filename Full path to the Log file to load
	 */
	public function load($filename) {
		$this->filename = $filename;
		$tmp = file_get_contents($filename);
		if ($tmp === FALSE || strlen($tmp) == 0)
			fatal("Failed to open ".$filename);

		$tmp = explode("---".PHP_EOL, $tmp);
		$this->head = $tmp[0];
		$this->body = $tmp[1];
		if (isset($tmp[2]))
			$this->tail = $tmp[2];
		else
			$this->tail = "";
	}

	/**
	 * Save the log to the work directory
	 *
	 * @param $filename Full path to the Log file to save
	 */
	public function save($filename = FALSE) {
		$contents  = $this->head."---".PHP_EOL.$this->body."---".PHP_EOL.$this->tail;
		if ($filename === FALSE)
			$filename = $this->filename;
		file_put_contents($filename, $contents);
	}

	public function get_head() { return $this->head; }
	public function append_head($str) { $this->head .= $str; }

	public function get_body() { return $this->body; }
	public function set_body($body) { $this->body = $body; }
	public function append_body($str) { $this->body .= $str; }

	/**
	 * Append a patch to the bottom of the Log body
	 *
	 * @param Patch object to append
	 */
	public function append_patch($p) {
		$this->append_body("# ".$p->subject.PHP_EOL);
		$this->append_body($p->commit_id.PHP_EOL.PHP_EOL);
	}

	/**
	 * Retrieve the contents of a tag and store in $var
	 *
	 * @param $line The string containing a tag
	 * @param $tag The tag to look for
	 * @param $var Variable to store the result
	 */
	private function get_tag($line, $tag, &$var) {
		$tag = strtolower($tag);
		if (strtolower(substr($line, 0, strlen($tag))) === $tag) {
			$tag = substr($line, strlen($tag));

			// Append to array if needed
			if (is_array($var))
				$var[] = $tag;
			else
				$var = $tag;
		}
	}

	/**
	 * Find requested tag in head and return it
	 *
	 * @param $tag Tag to look for
	 * @return Returns value for requested tag
	 */
	public function get_head_tag($tag) {
		if ($this->filename === FALSE)
			return FALSE;

		$head = explode(PHP_EOL, $this->get_head());

		foreach($head as $line)
			$this->get_tag($line, $tag.": ", $res);

		if ($res == NULL)
			return FALSE;
		
		return $res;
	}

	/**
	 * Set backport commit id for specified upstream commit id
	 *
	 * @param $upstream_id Upstream commit id
	 * @param $backport_id Backported commit id
	 * @return FALSE on failure
	 */
	public function update_commit($upstream_id, $backport_id) {
		if ($this->filename === FALSE)
			return FALSE;

		$body = explode(PHP_EOL, $this->get_body());

		// Find row
		for ($i = 0; $i < count($body); $i++) {
			$line = $body[$i];
			if (trim($line) == "")
				continue;

			$line = explode(" ", $line);
			if ($line[0] == "#")
				continue;
	
			if ($line[0] == $upstream_id) {
				$body[$i] = $upstream_id." ".$backport_id;
				break;
			}
		}

		if ($i == count($body))
			fatal("Couldn't find upstream commit: ".$upstream_id);

		$body = implode(PHP_EOL, $body);
		$this->set_body($body);
		$this->save();
	}

	/**
	 * Get the last applied commit from log
	 *
	 * @return Returns commit as array [upstream_id, backport_id]
	 */
	public function get_last_commit() {
		$body = $this->get_body();
		$body = explode(PHP_EOL, $body);

		$prev_line = "";
		foreach ($body as $line) {
			if ($line == "")
				continue;
			$line = explode(" ", $line);
			if ($line[0] == "#")
				continue;
			if (count($line) == 1)
				return $prev_line;
			if ($line[1] == "")
				return $prev_line;

			$prev_line = $line;
		}

		return $prev_line;
	}

	/**
	 * Find the next commit id to process from the commit log
	 *
	 * @return Returns upstream commit id of next commit to process
	 */
	public function get_next_commit() {
		$body = $this->get_body();
		$body = explode(PHP_EOL, $body);

		foreach ($body as $line) {
			if ($line == "")
				continue;
			$line = explode(" ", $line);
			if ($line[0] == "#")
				continue;
			if (count($line) == 1)
				return $line[0];
			if ($line[1] == "")
				return $line[0];
		}
	}

	/**
	 * Get the number of upstream commits in log
	 *
	 * @return Returns number of commits in log
	 */
	public function get_num_commits() {
		$body = $this->get_body();
		$body = explode(PHP_EOL, $body);

		$i = 0;
		foreach ($body as $line) {
			$line = explode(" ", $line);
			if (strlen($line[0]) == 40)
				$i++;
		}

		return $i;
	}

	/**
	 * Get the index in log for a specified commit id
	 *
	 * @return Returns zero based index of specified commit id
	 */
	public function get_commit_index($commit_id) {
		$body = $this->get_body();
		$body = explode(PHP_EOL, $body);

		$i = 0;
		foreach ($body as $line) {
			$line = explode(" ", $line);
			if ($line[0] == "#")
				continue;
			if ($line[0] == "")
				continue;

			if ($commit_id == $line[0])
				return $i;

			$i++;
		}

		return FALSE;
	}

	/**
	 * Sanity-check last entry in log
	 *
	 * @param $git Git repo to check against
	 */
	function sanity_check_last() {
		// Sanity check log vs git-repo
		$last = $this->get_last_commit();
		if (isset($last[1]) && strlen($last[1]) == 40) {
			$p1 = new Patch(); // Upstream commit
			$p2 = new Patch(); // Backport commit
			$p1->parse_from_git($last[0]);
			$p2->parse_from_git($last[1]);
			if ($p1->subject != $p2->subject) {
				fatal("Commit log is corrupted. Must be fixed manually.\n(".
				      $p1->subject." != ".$p2->subject.")");
			}
		}
	}
}

class GitRepo {
	var $dir;

	public function set_dir($dir) { $this->dir = $dir; }
	public function get_dir() { return $this->dir; }

	// Run a shell command in the git repository directory
	public function cmd($cmd, &$output = FALSE, &$status = FALSE) {
		debug_git("git cmd: ".$cmd);
		exec("cd ".$this->dir." && ".$cmd, $output, $status);
	}

	// Returns the currently selected branch
	public function get_current_branch() {
		$this->cmd("git branch --show-current", $name);
		if (count($name) == 0)
			fatal("Failed to get current branch!");

		return $name[0];
	}

	// Returns the commit id of the latest committed patch
	public function get_current_commit_id() {
		$this->cmd("git rev-list HEAD~1..HEAD", $git_head);

		return $git_head[0];
	}

	public static function cmp_commits($a, $b) {
		$len = min(strlen($a), strlen($b));

		if (strncmp($a, $b, $len) == 0)
			return TRUE;

		return FALSE;
	}

	private function parse_status_paths($str, $line_skip) {
		$this->cmd("git status", $output);

		while (count($output) > 0 && $output[0] != $str)
			array_shift($output);

		// Parse the modified files from output
		$output = array_splice($output, $line_skip);
		$paths = array();
		foreach ($output as $o) {
			if ($o == "")
				break;
			$o = explode(":", $o);
			$paths[trim($o[1])] = trim($o[0]);
		}

		return $paths;
	}

	// Returns an array of unmerged paths
	public function get_unmerged_paths() {
		return $this->parse_status_paths("Unmerged paths:", 3);
	}

	// Returns an array of paths to be commited
	public function get_modified_paths() {
		return $this->parse_status_paths("Changes to be committed:", 2);
	}

	// Returns an array of paths not staged for commit
	public function get_unstaged_paths() {
		return $this->parse_status_paths("Changes not staged for commit:", 2);
	}

	public function add_all_unmerged() {
		$force = Options::get("force", FALSE);

		$fatal = $this->check_for_conflicts();
		if ($fatal && $force == FALSE)
			fatal("Unmerged paths still contain conflicts!");

		$unmerged = $this->get_unmerged_paths();
		foreach ($unmerged as $u => $type) {
			if ($type == "both modified")
				$this->cmd("git add ".$u);
			else if ($type == "deleted by us")
				$this->cmd("git rm ".$u);
			else
				error("Unknown unmerged type: ".$u);
		}

		$modified = $this->get_modified_paths();
		msg("Added files:");
		foreach ($modified as $m => $type) {
			green("\t".$m);
		}
	}

	// Switch to a different git branch
	public function change_branch() {
		$branch = Options::get("branch");
		$branch_point = Options::get("branch-point");

		if ($branch == "")
			fatal("Invalid branch. Did you run setup properly?");

		if ($this->get_current_branch() != $branch) {
			$unmerged = $this->get_unmerged_paths();
			$unstaged = $this->get_unstaged_paths();
			if (count($unmerged) != 0 || count($unstaged) != 0)
				fatal("Couldn't change branch due to unmerged / unstaged changes");

			$this->cmd("git checkout ".$branch." 2> /dev/null", $output, $status);
			if ($status != 0)
				$this->cmd("git checkout -b ".$branch." ".$branch_point);
		}

		// Sanity check the branch
		if ($this->get_current_branch() != $branch)
			fatal("Couldn't create/find correct branch");
	}

	// Find where in the patch series we currently are
	public function find_commit_index($commit, $patches) {
		$num = count($patches);
		for ($i = 0; $i < $num; $i++) {
			if ($commit == $patches[$i]->commit_id) {
				break;
			}
		}

		// If commit is not found we start from beginning (index 0)
		if ($i == $num)
			$i = 0;

		return $i;
	}

	public function skip_commit($p, $reason) {
		$log = Globals::$log;

		$this->cmd("git am --skip");
		$log->update_commit($p->commit_id, $reason);
	}

	public function check_for_conflicts() {
		// Check that none of the unmerged paths still contain conflicts
		$unmerged = $this->get_unmerged_paths();
		$conflicts = FALSE;

		foreach ($unmerged as $u => $type) {
			$this->cmd("grep -Hn \"<<<<<<\" ".$u, $res);
			if (count($res) > 0)
				$conflicts = TRUE;
			// Documenation sometimes contains lots of ===== so remove this for now
			/*
			$this->cmd("grep -Hn \"======\" ".$u, $res);
			if (count($res) > 0)
				$conflicts = TRUE;
			*/
			$this->cmd("grep -Hn \">>>>>>\" ".$u, $res);
			if (count($res) > 0)
				$conflicts = TRUE;
		}

		return $conflicts;
	}

	public function check_am_session() {
		$this->cmd("git status", $res);
		if ($res[1] == "You are in the middle of an am session.")
			return TRUE;
		else
			return FALSE;
	}

	public function check_rebase_session() {
		$this->cmd("git status", $res);
		if (strpos($res[0], "interactive rebase in progress") === 0)
			return TRUE;
		else
			return FALSE;
	}

	public function check_cherrypick_session() {
		$this->cmd("git status", $res);
		if (strpos($res[1], "You are currently cherry-picking commit") === 0)
			return TRUE;
		else
			return FALSE;
	}

	public function check_any_session() {
		$in_session = FALSE;
		if ($this->check_am_session()) {
			debug("In AM session");
			$in_session = TRUE;
		} else if ($this->check_rebase_session()) {
			debug("In rebase session");
			$in_session = TRUE;
		} else if ($this->check_cherrypick_session()) {
			debug("In cherrypick session");
			$in_session = TRUE;
		}

		return $in_session;
	}

	function check_for_cherry_pick($p)
	{
		$log = Globals::$log;

		// Check if patch is already cherry picked
		$range_start = Options::get("range-start");
		$this->cmd("git log ".$range_start."~".CHERRY_PICK_HISTORY.
			   "..".$range_start." -n1 --oneline --grep=\"cherry picked from commit ".
			   $p->commit_id."\"", $res);

		if (count($res) > 0) {
			info("Found i915 cherry-pick (".$res[0].")");
			$res = explode(" ", $res[0]);
			return $res[0];
		}

		unset($res);
		$this->cmd("git rev-list --no-merges -n1 --oneline HEAD --grep \"".
			  addslashes($p->subject)."\"", $res);

		if (count($res) > 0) {
			$commit_id = explode(" ", $res[0])[0];
			$res = explode(" ", $res[0]);
			unset($res[0]);
			$subject = implode(" ", $res);

			if (!GitRepo::cmp_commits($commit_id, $p->commit_id) &&
						  $subject == $p->subject) {
				info("Found cherry-pick (".$commit_id.")");
				return $commit_id;
			}
		}

		return FALSE;
	}

	public function get_backported_commits() {
		$start = Options::get("branch-point");
		$branch = Options::get("branch");
		$this->cmd("git rev-list --reverse ".$start."..".$branch, $res);

		return $res;
	}
}

function array_to_str($array)
{
	$out = "";
	foreach($array as $line)
		$out .= $line."\n";

	return $out;
}

// Returns filenames for all the exported patches
function get_patch_filenames($dir)
{
	$dir = realpath($dir);
	exec("find ".$dir."| sort | grep \"\\.patch\"", $files);

	return $files;
}

function launch_editor($unmerged, $commit_id)
{
	$log = Globals::$log;
	$git = Globals::$git;

	$patch_filename = "/tmp/".$commit_id.".patch";
	$git->cmd("git show ".$commit_id." > ".$patch_filename, $output, $status);
	if ($status != 0)
		fatal("Failed to launch editor for commit ".$commit_id);

	$target_branch = Options::get("range-stop");

	foreach ($unmerged as $u => $type) {
		if ($type == "deleted by us")
			continue;

		// Figure out the extension so that the editor can do syntax highlighting
		$info = pathinfo($u);
		$file_ext = isset($info['extension']) ? $info['extension'] : "";
		if ($file_ext != "")
			$file_ext = ".".$file_ext;
		$solution_name = "solution-tmp".$file_ext;

		// Store the target version of the file (eg git show v5.5:<filename>)
		$git->cmd("git show ".$target_branch.":".$u." | ".
			"dd of=/tmp/".$solution_name." 2> /dev/null", $output, $status);

		// Add the entire path to modified files
		$u = $git->get_dir()."/".$u;

		// Find line number for first conflict
		$res = "";
		$git->cmd("grep -n \"<<<<<<\" ".$u, $res);
		if (count($res) > 0) {
			$res = explode(":", $res[0]);
			$line_no = " +".$res[0];
		} else {
			$line_no = "";
		}

		// Open vim with all the relevant files
		passthru("vim -O ".$line_no." ".$u." /tmp/".$solution_name." ".$patch_filename." 2> /dev/null");

		exec("rm /tmp/".$solution_name);
	}

	exec("rm ".$patch_filename);
}

function cmd_export($argv)
{
	$work_dir = Options::get("work-dir");

	$log = Globals::$log;
	$git = Globals::$git;

	$start = Options::get("range-start");
	$stop = Options::get("range-stop");
	$paths = Options::get("paths");

	// Execute git format-patch
	echo "Exporting patches...";

	exec("mkdir -p ".$work_dir."/patches/");
	$git->cmd("git format-patch --no-renames --topo-order --keep-subject --no-merges -o ".
		 $work_dir."/patches/ ".$start."..".$stop." -- ".$paths);

	$log->set_body("#         <Upstream commit id>".
		       "                   <Backported commit id>\n");
	$files = get_patch_filenames($work_dir."/patches");
	$patches = array();
	foreach ($files as $file) {
		$p = new Patch();
		$p->parse($file);
		$patches[] = $p;
		$log->append_patch($p);
	}

	$log->save($work_dir."/commits.log");

	echo count($files)."\n";
	exit();
}

function resolve_conflicts($commit_id)
{
	$git = Globals::$git;

	$in_session = $git->check_any_session();
	if (!$in_session) {
		error("Not in a conflict session. Cannot resolve conflicts.");
		return;
	}

	$unmerged = $git->get_unmerged_paths();

	launch_editor($unmerged, $commit_id);

	msg("Resolve done");
	$git->add_all_unmerged();
}

function cmd_resolve($argv)
{
	if (!isset($argv[2]))
		fatal("Commit id not specified");

	$commit_id = $argv[2];
	debug("Resolving conflict from ".$commit_id);

	resolve_conflicts($commit_id);
}

function cmd_apply($argv)
{
	$work_dir = Options::get("work-dir");
	$force = Options::get("force", FALSE);

	$log = Globals::$log;
	$git = Globals::$git;

	$branch = Options::get("branch");
	$range_start = Options::get("range-start");

	$git->change_branch();

	$patches = Patch::get_patches($work_dir."/patches");

	$num_patches = count($patches);
	if ($num_patches == 0)
		fatal("No patches to apply. Did you forget to run export?");

	$log->sanity_check_last();

	$next_commit = $log->get_next_commit();
	$i = $git->find_commit_index($next_commit, $patches);
	for (; $i < $num_patches; $i++) {
		$p = $patches[$i];

		// Check if we're in an am session
		if ($git->check_am_session()) {
			$unmerged = $git->get_unmerged_paths();
			$unstaged = $git->get_unstaged_paths();

			if (count($unmerged) > 0 || count($unstaged) > 0) {
				error("Repository contains unmerged/unstaged paths. Solve conflict before continuing.");
				launch_editor($unmerged, $p->commit_id);

				// If all conflicts are fixed we automatically add them
				// User can also force the changes even with conflicts by adding the --force option
				if ($git->check_for_conflicts() == FALSE) {
					cmd_add($argv);
				} else {
					error("Unmerged paths still contain conflicts");
					if ($force == TRUE) {
						info("Force adding since --force was specified. Rerun apply to continue.");
						cmd_add($argv);
					} else {
						msg("Add option --force to add all files anyway");
					}
				}

				exit(1);
			}

			if (count($git->get_modified_paths()) > 0) {
				debug("In AM session with modified paths. git am --contine");
				$git->cmd("git am --continue");

				$last_id = $git->get_current_commit_id();
				$log->update_commit($p->commit_id, $last_id);
				green("Applied\t(".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
			} else {
				debug("In AM session WITHOUT modified paths. git am --skip");
				$git->cmd("git am --skip");
				$log->update_commit($p->commit_id, "empty");
				info("Empty\t(".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
			}

			continue;
		}

		$filename = $p->filename;
		$output_am = "";

		$old_id = $git->get_current_commit_id();
		$git->cmd("git am --3way ".$filename." 2> /dev/stdout", $output_am, $status);
		$new_id = $git->get_current_commit_id();

		// Check if patch did not apply
		if ($status != 0) {
			// Save git am output to file so we can show it in edit (vim, emacs, etc.)
			file_put_contents($work_dir."/output.tmp", array_to_str($output_am));

			$cherry_id = $git->check_for_cherry_pick($p);
			if ($cherry_id !== FALSE) {
				info("Cherry picked (".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
				$log->update_commit($p->commit_id, "cherry-picked-by ".$cherry_id);
				$git->cmd("git am --abort");
				continue;
			}

			delimiter();
			echo "Unmerged paths:\n";
			$unmerged = $git->get_unmerged_paths();
			foreach ($unmerged as $u => $type)
				error($u);

			delimiter();
			error("Failed patch: ".basename($p->filename));

			delimiter();
			echo "Fix conflict and rerun apply.\n";
			info("(IMPORTANT! Do NOT run: git am --continue)");

			launch_editor($unmerged, $p->commit_id);

			// If all conflicts are fixed we automatically add them
			if ($git->check_for_conflicts() == FALSE) {
				cmd_add($argv);
				exit(0);
			} else {
				error("Unmerged paths still contain conflicts");
			}

			exit(1);
		}

		// Patch might not have introduced changes thus did not get applied (not needed)
		if ($old_id == $new_id) {
			$cherry_id = $git->check_for_cherry_pick($p);
			if ($cherry_id !== FALSE) {
				info("Cherry picked (".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
				$log->update_commit($p->commit_id, "cherry-picked-by ".$cherry_id);
				continue;
			}

			info("Empty\t(".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
			$log->update_commit($p->commit_id, "empty");
			continue;
		}
		$log->update_commit($p->commit_id, $new_id);
		green("Applied (".($i + 1)."/".$num_patches.") ".$p->commit_id." ".$p->subject);
	
/*
		$git->cmd("make -j16 M=drivers/gpu/drm 2> /dev/null", $res, $status);
		if ($status != 0)
			error("Compilation failed!");
*/
	}

	exit();
}

function cmd_skip($argv)
{
}

function cmd_setup($argv)
{
	$work_dir = Options::get("work-dir");
	$branch = Options::get("branch");
	$branch_point = Options::get("branch-point");
	$range_start = Options::get("range-start");
	$range_stop = Options::get("range-stop");
	$git_dir = Options::get("git-dir");
	$paths = Options::get("paths");

	$log = Globals::$log;
	$log->append_head("Range-start: ".$range_start."\n");
	$log->append_head("Range-stop: ".$range_stop."\n");
	$log->append_head("Branch: ".$branch."\n");
	$log->append_head("Branch-point: ".$branch_point."\n");
	$log->append_head("Git-dir: ".$git_dir."\n");
	$log->append_head("Paths: ".$paths."\n");

	$log->save($work_dir."/commits.log");

	info("Setup saved to ".$work_dir."/commits.log");
	exit(0);
}

function cmd_add($argv)
{
	$work_dir = Options::get("work-dir");
	$git = Globals::$git;

	$branch = Options::get("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$git->change_branch();

	$git->add_all_unmerged();

	exit(0);
}

function cmd_restart($argv)
{
	$work_dir = Options::get("work-dir");

	$log = Globals::$log;
	$git = Globals::$git;

	$git->change_branch();
	$branch = Options::get("branch");

	if ($git->check_am_session()) {
		$git->cmd("git am --abort");
	}

	$git->cmd("git checkout master");
	$git->cmd("git branch -D ".$branch);

	$log->set_body("");
	$files = get_patch_filenames($work_dir."/patches");
	$patches = array();
	foreach ($files as $file) {
		$p = new Patch();
		$p->parse($file);
		$patches[] = $p;
		$log->append_patch($p);
	}

	$log->save($work_dir."/commits.log");

}

function cmd_sanity_check($argv)
{
	$work_dir = Options::get("work-dir");
	$fix = Options::get('fix', FALSE);

	$log = Globals::$log;
	$git = Globals::$git;

	$branch = Options::get("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$range_start = Options::get("range-start");
	$range_stop = Options::get("range-stop");

	$git->change_branch();

	$body = $log->get_body();
	$body = explode(PHP_EOL, $body);

	$backported = $git->get_backported_commits();

	$i = 0;
	$j = 0;
	$num_faults = 0;
	$num_fixed = 0;
	foreach ($body as $line) {
		$i++;
		$line = explode(" ", $line);
		if ($line == "")
			continue;
		if ($line[0] == "")
			continue;
		if ($line[0][0] == "#")
			continue;
		if (!isset($line[1]) || $line[1] == "")
			continue;
		if (strlen($line[1]) != 40 && $line[1] != "empty")
			continue;

		$p1 = new Patch(); // Upstream commit
		$p1->parse_from_git($line[0]);

		if ($line[1] == "empty") {
			debug("Processing empty: ". $p1->commit_id." ".$p1->subject);
			$res = NULL;
			$git->cmd("git rev-list --no-merges -n1 --oneline HEAD --grep \"".
				  addslashes($p1->subject)."\"", $res);

			if (count($res) == 0)
				continue;

			$commit_id = explode(" ", $res[0])[0];
			$res = explode(" ", $res[0]);
			unset($res[0]);
			$subject = implode(" ", $res);
				
			if (!GitRepo::cmp_commits($commit_id, $p1->commit_id) &&
			    $subject == $p1->subject) {
				info("Found cherry-pick: ".$commit_id." ".$subject);

				if ($fix === TRUE) {
					info("Fixing: Change empty into cherry pick");
					$log->update_commit($p1->commit_id, "cherry-picked-by ".$commit_id);
					$num_fixed++;
				}
			}
			continue;
		}

		$p2 = new Patch(); // Backport commit
		$p2->parse_from_git($line[1]);
		// info("\"".$p1->subject."\" == \"".$p2->subject."\"");

		$bp_id = $backported[$j];
		$p3 = new Patch();
		$p3->parse_from_git($bp_id);

		// HACK: Sometimes there are double spaces in some subjects.
		// They must be removed before comparing

		$p1->subject = str_replace("  ", " ", $p1->subject);
		$p2->subject = str_replace("  ", " ", $p2->subject);
		$p3->subject = str_replace("  ", " ", $p3->subject);

		debug("i=".$i." j=".$j);
		debug("Upstream\t".$p1->commit_id." ".$p1->subject);
		debug("In log\t\t".$p2->commit_id." ".$p2->subject);
		debug("In repo\t\t".$p3->commit_id." ".$p3->subject);

		if ($p1->commit_id == $p2->commit_id)
			fatal("Comparing the same commit. This shouldn't happen!");

		if ($p1->subject != $p2->subject) {
			error("Commit log is inconsistent at commit: ".$i);
			echo "\t".$p1->commit_id." ".$p1->subject."\n".
			     "\t".$p2->commit_id." ".$p2->subject."\n";
			$num_faults++;
		}

		if ($p2->commit_id != $bp_id) {
			error("Found non-matching log vs git repo commit");
			$num_faults++;

			// Check if rebase must have happened
			if ($p1->subject == $p2->subject && $p1->subject == $p3->subject) {
				// Looks like a problem we can fix
				if ($fix == TRUE) {
					info("Fixing: Updating rebased commit id: ".$p1->commit_id);
					$log->update_commit($p1->commit_id, $p3->commit_id);
					$num_fixed++;
				}
			} else {
				error("Our commit log is out of sync with git log!");
				if ($fix == TRUE) {
					error("Cannot continue, aborting FIX session!");
					return;
				}
			}
		}

		$j++;
	}

	msg("Processed ".$j." commits");
	if ($num_faults == 0)
		green("Found ".$num_faults." problems");
	else
		error("Found ".$num_faults." problems");

	if ($fix == TRUE)
		info("Fixed ".$num_fixed." commits");
}


function cmd_rebase($argv)
{
	$work_dir = Options::get("work-dir");

	$log = Globals::$log;
	$git = Globals::$git;

	$branch = Options::get("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$range_start = Options::get("range-start");
	$range_stop = Options::get("range-stop");
	$fix = Options::get("fix", FALSE);

	$git->change_branch();

	$body = $log->get_body();
	$body = explode(PHP_EOL, $body);

	$backported = $git->get_backported_commits();

	$i = 0;
	$j = 0;
	$num_faults = 0;
	$num_fixed = 0;
	$upstream_commits = array();
	foreach ($body as $line) {
		$i++;
		$line = explode(" ", $line);
		if ($line == "")
			continue;
		if ($line[0] == "")
			continue;
		if ($line[0][0] == "#")
			continue;
		if (!isset($line[1]) || $line[1] == "")
			continue;
		if (strlen($line[1]) != 40 && $line[1] != "empty")
			continue;

		echo "\rProgress: ".round(($i / count($body) * 100), 0)."%\tRebased: ".$num_fixed;

		$p1 = new Patch(); // Upstream commit
		$p1->parse_from_git($line[0]);

		if ($line[1] == "empty")
			continue;

		if (in_array($p1->commit_id, $upstream_commits)) {
			error("\nCommit: ".$p1->commit_id." is already backported. ".
			"Perhaps you cherry-picked a commit instead of rebasing it?");
			return;
		}
		$upstream_commits[] = $p1->commit_id;

		$p2 = new Patch(); // Backport commit
		$p2->parse_from_git($line[1]);

		$bp_id = $backported[$j];
		$p3 = new Patch();
		$p3->parse_from_git($bp_id);

		// HACK: Sometimes there are double spaces in some subjects.
		// They must be removed before comparing

		$p1->subject = str_replace("  ", " ", $p1->subject);
		$p2->subject = str_replace("  ", " ", $p2->subject);
		$p3->subject = str_replace("  ", " ", $p3->subject);

		debug("i=".$i." j=".$j);
		debug("Upstream\t".$p1->commit_id." ".$p1->subject);
		debug("In log\t\t".$p2->commit_id." ".$p2->subject);
		debug("In repo\t\t".$p3->commit_id." ".$p3->subject);

		if ($p1->commit_id == $p2->commit_id)
			fatal("\nComparing the same commit. This shouldn't happen!");

		if ($p1->subject != $p2->subject) {
			error("\nCommit log is inconsistent at commit: ".$i);
			echo "\t".$p1->commit_id." ".$p1->subject."\n".
			     "\t".$p2->commit_id." ".$p2->subject."\n";
			$num_faults++;
		}

		if ($p2->commit_id != $bp_id) {
			$num_faults++;

			// Check if rebase must have happened
			if ($p1->subject == $p2->subject && $p1->subject == $p3->subject) {
				// Looks like a problem we can fix
				debug("\nRebasing commit id: ".$p1->commit_id);
				$log->update_commit($p1->commit_id, $p3->commit_id);
				$num_fixed++;
			} else {
				msg("\n\n".$p1->subject."\n".$p1->commit_id);
				fatal("Our commit log is out of sync with git log!");
			}
		}

		$j++;
	}

	msg("\nProcessed ".$j." commits");
	info("Rebased ".$num_fixed." commits");
}

function cmd_diffstat($argv)
{
	$work_dir = Options::get("work-dir");

	$git = Globals::$git;

	$branch = Options::get("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$range_stop = Options::get("range-stop");
	$paths = Options::get("paths");

	$git->change_branch();

	$res = FALSE;
	$git->cmd("git diff --stat ".$branch." ".$range_stop." -- ".$paths, $res, $status);
	if ($status != 0)
		fatal("Failed to diff");

	echo array_to_str($res);
}

function cmd_status($argv)
{
	$work_dir = Options::get("work-dir");

	$log = Globals::$log;
	$git = Globals::$git;

	$range_stop = Options::get("range-stop");
	$paths = Options::get("paths");
	$branch = Options::get("branch");

	$git->change_branch();

	$last_commit = $log->get_last_commit();
	$num_commits = $log->get_num_commits();

	if ($last_commit == FALSE || $num_commits == 0) {
		echo "No commits exported or backported. Run \"b2tf export\" and then \"b2tf apply\" to start backporting.\n";
		return;
	}

	$last_commit = $last_commit[0];
	$last_num = $log->get_commit_index($last_commit) + 1;

	echo "Progress ".(round(($last_num / $num_commits) * 100, 0))."% (".$last_num."/".$num_commits." commits)\n";

	$res = FALSE;
	$git->cmd("git diff --stat ".$branch." ".$range_stop." -- ".$paths, $res, $status);
	if ($status != 0)
		fatal("Failed to diff");

	if ($last_num >= $num_commits) {
		msg("Backport is done!");
	}

	$last_line = count($res) - 1;
	msg(trim($res[$last_line])."\n");

	$next_commit = $log->get_next_commit();
	$patches = Patch::get_patches($work_dir."/patches");
	$p = Patch::get_by_commit($next_commit, $patches);

	if ($git->check_any_session())
		echo "In conflict session\n";
	else
		echo "Not in conflict session.\n";

	if ($p === FALSE) {
		echo "No more patches to backport\n";
		return;
	}

	echo "Next commit:\n";
	echo $p->commit_id." ".$p->subject."\n";

	$unmerged = $git->get_unmerged_paths();
	$unstaged = $git->get_unstaged_paths();
	$modified = $git->get_modified_paths();

	if (count($modified) > 0) {
		echo "Modified:\n";
		foreach ($modified as $m) {
			green("\t".$m);
		}
	}

	if (count($unstaged) > 0) {
		echo "Unstaged:\n";
		foreach ($unstaged as $u) {
			green("\t".$u);
		}
	}

	if (count($unmerged) > 0) {
		echo "Unmerged:\n";
		foreach ($unmerged as $u) {
			error("\t".$u);
		}
	}

	echo "\n";
}

function cmd_diff($argv)
{
	$work_dir = Options::get("work-dir");

	$git = Globals::$git;

	$branch = Options::get("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$range_stop = Options::get("range-stop");
	$paths = Options::get("paths");

	$git->change_branch();

	// If a list of files/paths are provided we use that instead of the normal paths
	if (isset($argv[2])) {
		$args = $argv;
		array_shift($args);
		array_shift($args);

		$paths = implode(" ", $args);
	}

	$git->cmd("git diff ".$branch." ".$range_stop." -- ".$paths, $res, $status);
	if ($status != 0)
		fatal("Failed to diff");

	echo array_to_str($res);
	delimiter();

	$res = FALSE;
	$git->cmd("git diff --stat ".$branch." ".$range_stop." --  ".$paths, $res, $status);
	if ($status != 0)
		fatal("Failed to diff");

	echo array_to_str($res);
}

function cmd_log($argv)
{
	$work_dir = Options::get("work-dir");

	$log = Globals::$log;
	$git = Globals::$git;

	$branch = Options::get("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$git->change_branch();

	$body = $log->get_body();
	$body = explode(PHP_EOL, $body);

	for ($i = 0; $i < count($body); $i++) {
		$line = explode(" ", $body[$i]);

		if (!isset($line[1]))
			continue;

		if (strlen($line[0]) == 40 && strlen($line[1]) == 40) {
			$p = new Patch();
			$p->parse_from_git($line[0]);

			msg($line[0]." ".$line[1]." ".$p->subject);
		}
	}
}

function insert_tags_in_patch($filename, $tags, $signature = "")
{
	$data = file_get_contents($filename);
	if ($data === FALSE)
		fatal("Failed to open patch file for inserting tags");

	debug("Adding tags to: ".$filename);
	$data = explode(PHP_EOL, $data);

	// Find appropriate position for tags
	for ($i = 0; $i < count($data); $i++) {
		$str = "Content-Transfer-Encoding: ";
		if (strncmp($str, $data[$i], strlen($str)) == 0)
			break;
	}

	// If above tag is not found, try the subject tag
	if ($i == count($data)) {

		// Find index for subject tag
		for ($i = 0; $i < count($data); $i++) {
			$str = "Subject: ";
			if (strncmp($str, $data[$i], strlen($str)) == 0) {
				// continue to empty line between subject and body
				while (strcmp(trim($data[$i + 1]), "") != 0)
					$i++;

				break;
			}
		}
	}

	if ($i == count($data))
		fatal("Couldn't find subject tag in patch");

	debug("Adding tags: ".print_r($tags, TRUE));
	array_splice($data, ($i + 1), 0, $tags);

	$data = implode(PHP_EOL, $data);

	// Add signature tag
	if ($signature != "") {
		$data = explode(PHP_EOL."---".PHP_EOL, $data);

		// SUSE kernel-source wants an Acked-by instead of a Signed-off-by
		$data[0] = $data[0].PHP_EOL."Acked-by: ".$signature;

		$data = implode(PHP_EOL."---".PHP_EOL, $data);
	}

	file_put_contents($filename, $data);

}

function suse_format_patch($p1, $p2, $signature, $refs)
{
	$git = Globals::$git;

	$mainline = $p2->get_mainline_tag();
	if ($mainline === FALSE)
		fatal("Couldn't find mainline tag for ".$p2->commit_id." ".$p2->subject);

	$tags = array(	"Git-commit: ".$p2->commit_id,
			"Patch-mainline: ".$mainline,
			"References: ".$refs);

	insert_tags_in_patch($p1->filename, $tags, $signature);
}

// Create a list of all backported patches from the suse repo (to check for duplicates)
function get_suse_backports($suse_repo_path)
{
	exec("find ".$suse_repo_path."/patches.suse/ | grep -v \"~\" | xargs cat | grep -i 'git-commit\|alt-commit\|no-fix'", $lines);

	$commits = array();
	$num_lines = count($lines);
	$i = 1;
	foreach ($lines as $line) {
		$line = explode(" ", $line);
		$commit_id = $line[1];
		if (strlen($commit_id) != 40)
			$commit_id = $line[2];

		if (strlen($commit_id) != 40) {
			error("\nFound invalid backport commit id: ".var_dump($line));
			continue;
		}

		$commits[] = $commit_id;
	}

	msg("\nFound ".count($commits)." suse backports");

	return $commits;
}

function get_suse_blacklists($suse_repo_path)
{
	$file = file_get_contents($suse_repo_path."/blacklist.conf");
	$lines = explode(PHP_EOL, $file);

	$list = array();
	foreach ($lines as $line) {
		if ($line == "")
			continue;

		if ($line[0] == "#")
			continue;

		$line = explode(" ", $line);
		if (count($line) <= 1)
			continue;

		if (strlen($line[0]) != 40)
			continue;

		$list[] = $line[0];
	}

	return $list;
}

function cmd_format_suse($argv)
{
	$work_dir = Options::get("work-dir");

	$log = Globals::$log;
	$git = Globals::$git;

	$start = Options::get("range-start");

	// Stop in this context is the tip of the branch and not range-stop
	$stop = Options::get("branch");

	$signature = Options::get("signature");
	$refs = Options::get("refs");
	$suse_repo_path = Options::get("suse-repo-path");

	msg("start:\t\t".$start);
	msg("stop:\t\t".$stop);
	msg("signature:\t".$signature);
	msg("refs:\t\t".$refs);

	$branch = Options::get("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$suse_backports = get_suse_backports($suse_repo_path);

	$git->change_branch();

	exec("mkdir -p ".$work_dir."/patches.suse");
	exec("rm ".$work_dir."/patches.suse/*");

	info("Exporting patches...");
	$git->cmd("git format-patch -o ".$work_dir."/patches.suse/ --no-renames --keep-subject ".$start."..".$stop);

	$body = $log->get_body();
	$body = explode(PHP_EOL, $body);

	info("Formatting patches...");
	$patches = Patch::get_patches($work_dir."/patches.suse");
	$suse_filenames = "";
	for ($i = 0, $j = 0; $i < count($body); $i++) {
		$line = explode(" ", $body[$i]);
		if (strlen($line[0]) == 40 && strlen($line[1]) == 40) {
			if (!isset($patches[$j]))
				fatal("More patches in log than in backport!");

			// We get more correct subject lines when parsing from git so do that here
			$p_file = $patches[$j];

			$p1 = new Patch();
			$p1->parse_from_git($p_file->commit_id);

			$p2 = new Patch();
			$p2->parse_from_git($line[0]);

			if (in_array($p2->commit_id, $suse_backports)) {
				// Patch is already backported so skip it
				msg("(already backported) ".$p_file->commit_id." ".$p_file->subject);
				exec("rm ".$work_dir."/patches.suse/".basename($p_file->filename));
				$j++;
				continue;
			}

			if ($p1->subject != $p2->subject)
				error("Subject not matching\n".$p1->subject." != ".$p2->subject);

			suse_format_patch($p_file, $p2, $signature, $refs);
			msg("(".($j + 1)."/".count($patches).") ".$p2->commit_id." ".$p2->subject);

			$suse_filenames .= "patches.suse/".basename($p_file->filename)." ";
			$j++;
		}
	}

	exec("cp ".$work_dir."/patches.suse/* ".$suse_repo_path."/patches.suse/");
	passthru("cd ".$suse_repo_path." && ./scripts/git_sort/series_insert.py ".$suse_filenames);

	file_put_contents($work_dir."/patches.suse/filenames.log", $suse_filenames);
}

function cmd_list_cherry_picks($argv)
{
	$work_dir = Options::get("work-dir");

	$log = Globals::$log;
	$git = Globals::$git;

	$branch = Options::get("branch");
	if ($branch == "")
		fatal("Invalid branch in commit.log. Perhaps rerun setup?");

	$git->change_branch();

	$body = $log->get_body();
	$body = explode(PHP_EOL, $body);
	foreach ($body as $line) {
		$line = explode(" ", $line);
		if (count($line) < 3)
			continue;
		if ($line[1] != "cherry-picked-by")
			continue;

		$p1 = new Patch();
		$p1->parse_from_git($line[0]);
		$p2 = new Patch();
		$p2->parse_from_git($line[2]);

		if ($p1->subject != $p2->subject)
			error("Subjects doesn't match");

		msg($line[0]." # Duplicate of ".$p2->commit_id.": ".$p2->subject);
	}
}

function parse_options($argv)
{
	$options = Options::$options;;

	if (isset($argv[1]))
		$command = $argv[1];
	else
		return;

	$work_dir = Options::get("work-dir");

	// Getting the git-dir option here will not look in the log since it's not loaded
	$git_dir = Options::get("git-dir");
	Globals::$git->set_dir($git_dir);

	// Commands that don't require the log file
	switch ($command) {
	case "suse-fixes":
		cmd_suse_fixes($argv);
		exit(0);
	case "resolve":
		cmd_resolve($argv);
		exit(0);
	}

	Globals::$log->load($work_dir."/commits.log");

	// Getting the git-dir option here will include the log
	$git_dir = Options::get("git-dir");
	Globals::$git->set_dir($git_dir);

	// Commands that require the log file
	switch($command) {
	case "setup":
		cmd_setup($argv);
		exit(0);
	case "export":
		cmd_export($argv);
		exit(0);
	case "apply":
		cmd_apply($argv);
		exit(0);
	case "add":
		cmd_add($argv);
		exit(0);
	case "restart":
		cmd_restart($argv);
		exit(0);
	case "sanity-check":
		cmd_sanity_check($argv);
		exit(0);
	case "status":
		cmd_status($argv);
		exit(0);
	case "diffstat":
		cmd_diffstat($argv);
		exit(0);
	case "diff":
		cmd_diff($argv);
		exit(0);
	case "rebase":
		cmd_rebase($argv);
		exit(0);
	case "log":
		cmd_log($argv);
		exit(0);
	case "format-suse":
		cmd_format_suse($argv);
		exit(0);
	case "list-cherry-picks":
		cmd_list_cherry_picks($argv);
		exit(0);
	}
}

$opts = array(
	"range-start:",
	"range-stop:",
	"branch:",
	"branch-point:",
	"work-dir:",
	"git-dir:",
	"paths:",
	"signature:",
	"skip-review",
	"skip-fails",
	"refs:",
	"release:",
	"repo-tag:",
	"fix",
	"force",
	"fixes-file:",
	"file-type:",
	"suse-repo-path:",
	"only-alt-commits",
	"debug",
	"debug-git",
	);

$args = Options::parse($argv, $opts);

Util::get_user($username, $fullname, $path);
Storage::$path = $path."/.b2tf.xml";
Storage::load();

if (Options::get("debug", FALSE))
	Globals::$debug = TRUE;

if (Options::get("debug-git", FALSE))
	Globals::$debug_git = TRUE;

Globals::$log = new Log();
Globals::$git = new GitRepo();

parse_options($args);

?>

Usage: <?= $argv[0] ?> <options> <command>

--work-dir will be set to current directory if not specified

Commands:
  setup - Setup all backporting parameters
    --start=<range-start>
    --stop=<range-stop>
    --branch=<name-of-branch-to-do-backport-in>
    --work-dir=<working-directory>
    --git-dir=<git-repository-directory>
    --paths=<paths-in-git-repo-to-backport>
    Example:
    <?= $argv[0] ?> \
      --start=v5.4 --stop=v5.5 --branch=my-backport \
      --work-dir=./empty-dir --git-dir=./linux-git \
      --paths="include/drm/ drivers/gpu/drm/" \
      setup

  export - Runs git-format-patch over the specified range

  apply - Start re-applying the series

  diff [files] - Show diff between current tree vs target tree

  status - Show current status of backport and git repo

  resolve <commit-id> - Resolve conflicts from the specified commit

  suse-fixes - Automate backport of git-fixes to the SUSE repo
    --only-alt-commits	- Skip everything except Alt-commits
    --fixes-file	- provide a file containing commits
    --

  <ALL>
    --refs		- Provide contents of the reference tag
    --signature		- Provide the contents of the signature tag
    --skip-review	- Skip looking at the patch before atempting backport
    --skip-fails	- Skip patches that do not apply immediately
